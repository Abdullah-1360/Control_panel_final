# Module 9: Admin Control Panel (UI)
## Enterprise Operations Dashboard & Management Interface

**Module ID:** `MOD-09-ADMIN-PANEL`  
**Priority:** P0 (Critical Path - User Interface)  
**Status:** Implementation Ready  
**Version:** 2.0.0

---

## ðŸŽ¯ IMPLEMENTATION DECISIONS (Feb 11, 2026)

### Real-Time Updates (UPDATED)
- **Decision:** Server-Sent Events (SSE) for real-time updates with polling as fallback
- **Rationale:** Polling creates "thundering herd" problem (1000 users = 2000+ req/s). SSE reduces load by 92% and latency from 5-30s to <100ms
- **Implementation:** 
  - Primary: SSE via EventSource API with useSSE hook
  - Fallback: React Query polling (only if SSE fails 3 times)
  - Auto-reconnection with exponential backoff
- **Impact:** Scales to 10,000+ users vs 500 with polling
- **Reference:** See `ARCHITECTURAL_OPTIMIZATIONS.md` for complete architecture

### Request Deduplication (NEW)
- **Decision:** Implement request deduplication for expensive queries
- **Rationale:** 50 simultaneous users = 50 identical queries. Deduplication reduces to 1 query with result sharing
- **Implementation:** RequestDeduplicationInterceptor with Redis caching (5s TTL)
- **Impact:** 98% reduction in database load during traffic spikes
- **Applied to:** Dashboard stats, server utilization, incident stats

### WebSocket Implementation
- **Decision:** NOT using WebSocket - using SSE instead
- **Rationale:** SSE is unidirectional (perfect for our use case), simpler, works through proxies, lower overhead than WebSocket
- **Impact:** Bi-directional communication not needed for real-time updates

### Theme Support
- **Decision:** Dark mode required, light mode optional
- **Rationale:** Standard for developer/admin tools. Shadcn UI makes this trivial with CSS variables
- **Implementation:** Use `next-themes` with system preference detection

### Mobile Responsiveness
- **Decision:** Desktop-first, mobile-compatible
- **Rationale:** Complex data tables and terminal windows are rarely used on mobile. Optimize for desktop, ensure it doesn't break on mobile
- **Breakpoints:** Desktop (1024px+), Tablet (768px-1023px), Mobile (320px-767px)

### Internationalization (i18n)
- **Decision:** English only for Phase 1
- **Rationale:** Hard requirement for MVP speed. i18n slows down UI development significantly
- **Future:** Add i18n in Phase 2 if needed

### API Documentation
- **Decision:** Auto-generated Swagger docs from backend
- **Rationale:** Use `@nestjs/swagger` decorators. Keeps docs in sync with code automatically
- **Access:** Available at `/api/docs` endpoint

### User Documentation
- **Decision:** Embedded markdown docs in Admin Panel
- **Rationale:** Render a simple `/docs` page inside the Admin Panel that reads from markdown files
- **Location:** `frontend/docs/*.md` files rendered in-app

### Monorepo Structure
- **Decision:** Use TurboRepo or Nx for monorepo management
- **Rationale:** Share DTOs and TypeScript interfaces between backend and frontend for type safety
- **Structure:** `apps/api` (NestJS), `apps/web` (Next.js), `packages/shared` (types, utils)

---

## Executive Summary

### Business Value
The Admin Control Panel is the **primary user interface** for OpsManager, providing a unified, real-time dashboard for managing infrastructure, monitoring assets, responding to incidents, and executing automation workflows. It transforms complex backend APIs into an intuitive, actionable interface that empowers IT teams to operate efficiently.

**Key Business Benefits:**
- **Unified Operations:** Single pane of glass for all infrastructure management
- **Real-Time Visibility:** Live updates on system health, incidents, and automation
- **Reduced Training Time:** Intuitive UI reduces onboarding from weeks to days
- **Improved Productivity:** Dense, information-rich interface optimized for engineers
- **Mobile Accessibility:** Responsive design enables on-the-go incident response

### Technical Highlights
- **Next.js 14 App Router:** Server-side rendering, optimized routing, React Server Components
- **Real-Time Updates:** Server-Sent Events (SSE) for <100ms latency, polling fallback for reliability
- **Request Deduplication:** Redis-backed caching prevents thundering herd (98% load reduction)
- **Optimistic UI:** Instant feedback with background API synchronization
- **Type-Safe:** End-to-end TypeScript with shared types from backend
- **Accessible:** WCAG AA compliant, keyboard navigation, screen reader support
- **Performance:** <2s page load, <100ms real-time updates, code splitting
- **Scalability:** Supports 10,000+ concurrent users

### Module Dependencies
```
Module 9 (Admin Panel) depends on:
â”œâ”€â”€ Module 1: Authentication & Authorization (Login, RBAC, Session)
â”œâ”€â”€ Module 2: Server Connection Management (Server CRUD, Connection Testing)
â”œâ”€â”€ Module 3: Integration Hub (Integration Management)
â”œâ”€â”€ Module 5: Automation & Workflow Engine (Runbook Execution)
â”œâ”€â”€ Module 6: Incident Management (Incident Lifecycle, SLO Tracking, Postmortems)
â”œâ”€â”€ Module 7: Logging & Event Store (Log Viewer, Distributed Tracing)
â””â”€â”€ Module 8: Notification & Communication Bus (Notification Rules, On-Call Management)
```

---

## 1. Module Overview

### 1.1 Purpose
Provide a **unified, responsive, real-time web interface** for managing infrastructure, monitoring assets, resolving incidents, and executing automation workflows. The Admin Control Panel translates raw JSON APIs into actionable dashboards optimized for operational efficiency.

### 1.2 Scope

**In Scope:**
- Application shell (sidebar, header, navigation)
- Authentication UI (login, MFA, session management)
- SRE Dashboard (service health, SLO tracking, error budgets)
- Server management (CRUD, connection testing, metrics)
- Incident response center (Kanban board, timeline, postmortems)
- Runbook automation hub (execution, history, log viewer)
- Settings & configuration (Users, Roles, Integrations, Notifications, On-Call)
- Audit log viewer (searchable, filterable, distributed tracing)
- Real-time updates (polling)

**Out of Scope:**
- Asset management UI (Module 4 removed)
- Backend API implementation (handled by Modules 1-8)
- Mobile native apps (responsive web only)
- Advanced analytics/BI (future enhancement)
- Custom report builder (future enhancement)

### 1.3 Design Philosophy

**Core Principles:**
1. **Data Density:** Prefer dense tables and status badges over whitespace - this is a tool for engineers
2. **Real-Time:** Incidents and status changes update without page reloads (React Query polling + WebSocket)
3. **Optimistic UI:** Actions feel instant visually, with background API synchronization
4. **Progressive Disclosure:** Show essential information first, details on demand
5. **Keyboard-First:** All actions accessible via keyboard shortcuts
6. **Accessibility:** WCAG AA compliant for inclusive operations

---

## 2. Implementation Roadmap

### Sprint Breakdown (6-8 weeks)

#### Sprint 1: Foundation & Authentication (Week 1-2)
**Goal:** Setup project, implement authentication UI, application shell, SSE infrastructure

**Deliverables:**
- Next.js 14 project initialization with App Router
- shadcn/ui component library setup
- Login page with email/password form
- MFA verification flow
- JWT token management (memory + HTTP-only cookie)
- Auth guard middleware
- Application shell (sidebar, header, navigation)
- Toast notification system
- **SSE Infrastructure:**
  - useSSE custom hook with EventSource API
  - Auto-reconnection with exponential backoff
  - Fallback to polling mechanism
  - Connection status indicator

**Acceptance Criteria:**
- [ ] User can log in with email/password
- [ ] MFA challenge appears when required
- [ ] Tokens stored securely (access in memory, refresh in cookie)
- [ ] Protected routes redirect to login
- [ ] Sidebar navigation functional
- [ ] Toast notifications display for async actions
- [ ] SSE connection establishes successfully
- [ ] Auto-reconnection works after connection drop
- [ ] Fallback to polling after 3 failed SSE attempts

---

#### Sprint 2: Dashboard & Core Resources (Week 3-4)
**Goal:** Implement NOC dashboard, server management with SSE real-time updates

**Deliverables:**
- Dashboard with system health widgets
- Incident feed (top 5 open incidents) with SSE updates
- Server utilization charts with SSE updates
- Recent automation feed with SSE updates
- Server list page (table with filters, pagination)
- Server detail page (overview, connection status)
- **SSE Integration:**
  - Connect dashboard widgets to SSE event stream
  - Handle INCIDENT_CREATED, INCIDENT_UPDATED events
  - Handle SERVER_STATUS_CHANGED events
  - Handle AUTOMATION_COMPLETED events
  - Update React Query cache from SSE events

**Acceptance Criteria:**
- [ ] Dashboard loads in <2s
- [ ] Widgets display real-time data via SSE (<100ms latency)
- [ ] Server list fetches from Module 2 API
- [ ] Server detail shows connection status
- [ ] Filters and pagination work correctly
- [ ] SSE events update dashboard without page refresh
- [ ] Fallback to polling works if SSE unavailable

---

#### Sprint 3: Incident Management & Automation (Week 5-6)
**Goal:** Implement incident response center, automation hub with real-time SSE updates

**Deliverables:**
- Incident list page (table view) with SSE updates
- Incident Kanban board (drag-and-drop state changes)
- Incident detail page (timeline, war room) with live timeline via SSE
- Comment system for incidents
- Runbook library (available automations)
- Runbook runner (trigger execution)
- Execution history (past runs)
- **SSE Integration:**
  - Real-time incident status changes
  - Live timeline updates (comments, status changes, automation results)
  - Real-time runbook execution logs
  - Optimistic UI updates with SSE confirmation
- Log viewer modal (monospace, syntax highlighting)

**Acceptance Criteria:**
- [ ] Incident list displays from Module 6 API
- [ ] Kanban board allows drag-and-drop state changes
- [ ] Incident timeline shows event history
- [ ] Users can add comments to incidents
- [ ] Playbooks can be triggered from UI
- [ ] Execution logs display in modal

---

#### Sprint 4: Settings, Configuration & Polish (Week 7-8)
**Goal:** Implement settings pages, configuration UI, performance optimization

**Deliverables:**
- User management page (CRUD operations)
- Role management page (permission matrix)
- Integration configuration (WHM, WHMCS, Git)
- Notification rules builder
- Audit log viewer (searchable, filterable)
- Global search functionality
- Performance optimization (code splitting, lazy loading)
- Accessibility audit and fixes
- Mobile responsive testing

**Acceptance Criteria:**
- [ ] Users can be created/edited/deleted (RBAC enforced)
- [ ] Integrations can be configured and tested
- [ ] Notification rules can be created with conditions
- [ ] Audit logs searchable and filterable
- [ ] Global search returns relevant results
- [ ] Page load time <2s
- [ ] WCAG AA compliance verified
- [ ] Mobile responsive on all pages

---

## 2.5 Real-Time Architecture (SSE)

### 2.5.1 Server-Sent Events Implementation

**Overview:**
Replace polling with Server-Sent Events for real-time updates, reducing database load by 95% and improving latency from 5-30s to <100ms.

**Frontend Hook: useSSE**

```typescript
// frontend/src/hooks/useSSE.ts
import { useEffect, useRef, useState } from 'react';
import { useQueryClient } from '@tanstack/react-query';

interface UseSSEOptions {
  url: string;
  enabled?: boolean;
}

export function useSSE({ url, enabled = true }: UseSSEOptions) {
  const [isConnected, setIsConnected] = useState(false);
  const [reconnectAttempts, setReconnectAttempts] = useState(0);
  const eventSourceRef = useRef<EventSource | null>(null);
  const queryClient = useQueryClient();

  useEffect(() => {
    if (!enabled) return;

    const connect = () => {
      try {
        const token = localStorage.getItem('accessToken');
        const eventSource = new EventSource(`${url}?token=${token}`);

        eventSource.onopen = () => {
          console.log('SSE connected');
          setIsConnected(true);
          setReconnectAttempts(0);
        };

        eventSource.onmessage = (event) => {
          const data = JSON.parse(event.data);
          handleEvent(data, queryClient);
        };

        eventSource.onerror = (error) => {
          console.error('SSE error:', error);
          setIsConnected(false);
          eventSource.close();
          
          // Exponential backoff reconnection
          const attempts = reconnectAttempts + 1;
          setReconnectAttempts(attempts);
          
          if (attempts < 3) {
            const delay = Math.min(1000 * Math.pow(2, attempts), 30000);
            setTimeout(connect, delay);
          }
        };

        eventSourceRef.current = eventSource;
      } catch (error) {
        console.error('Failed to create EventSource:', error);
      }
    };

    connect();

    return () => {
      eventSourceRef.current?.close();
    };
  }, [url, enabled, reconnectAttempts]);

  return { isConnected, reconnectAttempts };
}

function handleEvent(event: any, queryClient: any) {
  switch (event.type) {
    case 'incident.created':
      queryClient.invalidateQueries({ queryKey: ['incidents'] });
      queryClient.setQueryData(['incidents'], (old: any) => ({
        ...old,
        incidents: [event.data, ...(old?.incidents || [])]
      }));
      break;

    case 'incident.status.changed':
      queryClient.setQueryData(['incident', event.data.id], event.data.incident);
      break;

    case 'log.added':
      queryClient.setQueryData(['logs', event.data.executionId], (old: any) => ({
        ...old,
        logs: [...(old?.logs || []), event.data]
      }));
      break;

    case 'automation.completed':
      queryClient.invalidateQueries({ queryKey: ['execution', event.data.id] });
      break;
  }
}
```

**Component Integration with Fallback:**

```typescript
// frontend/src/app/(dashboard)/incidents/page.tsx
export default function IncidentsPage() {
  const [useFallback, setUseFallback] = useState(false);

  // SSE connection
  const { isConnected, reconnectAttempts } = useSSE({
    url: '/api/v1/events/stream',
    enabled: !useFallback
  });

  // Fallback polling (only if SSE fails)
  const { data: incidents } = useQuery({
    queryKey: ['incidents'],
    queryFn: fetchIncidents,
    refetchInterval: useFallback ? 5000 : false,
    enabled: useFallback
  });

  // Switch to fallback after 3 failed reconnections
  useEffect(() => {
    if (reconnectAttempts >= 3) {
      setUseFallback(true);
    }
  }, [reconnectAttempts]);

  return (
    <div>
      {!isConnected && useFallback && (
        <Alert variant="warning">
          Real-time updates unavailable. Using polling fallback.
        </Alert>
      )}
      <IncidentList incidents={incidents} />
    </div>
  );
}
```

**Connection Status Indicator:**

```typescript
// frontend/src/components/layout/ConnectionStatus.tsx
export function ConnectionStatus() {
  const { isConnected } = useSSE({
    url: '/api/v1/events/stream'
  });

  return (
    <div className="flex items-center gap-2">
      <div className={cn(
        "h-2 w-2 rounded-full",
        isConnected ? "bg-green-500" : "bg-red-500"
      )} />
      <span className="text-sm text-muted-foreground">
        {isConnected ? "Live" : "Reconnecting..."}
      </span>
    </div>
  );
}
```

### 2.5.2 Event Types

**Supported SSE Events:**
- `incident.created` - New incident created
- `incident.updated` - Incident details updated
- `incident.status.changed` - Incident status transition
- `log.added` - New log entry added
- `server.status.changed` - Server connection status changed
- `automation.started` - Runbook execution started
- `automation.completed` - Runbook execution finished
- `notification.sent` - Notification delivered

### 2.5.3 Performance Characteristics

**Before (Polling):**
- 1000 users Ã— 5s polling = 200 req/s
- Database queries: 200/s (most returning no changes)
- Latency: 5-30 seconds
- Scalability: ~500 concurrent users

**After (SSE):**
- 1000 users = 1000 persistent connections
- Events: ~167/s (only on actual changes)
- Database queries: ~10/s (95% reduction)
- Latency: <100ms
- Scalability: 10,000+ concurrent users

---

## 3. Detailed Functional Requirements

### 3.1 Application Shell

#### FR-UI-001: Global Layout & Navigation
**Priority:** P0 (Critical)

**Description:** Persistent frame surrounding every page with navigation, status, and user context.

**Components:**

**Sidebar (Collapsible):**
- Dashboard (home icon)
- Servers (server icon)
- Assets (database icon)
- Incidents (alert-circle icon)
- Automations (zap icon)
- Integrations (plug icon)
- Settings (settings icon)
- Logs (file-text icon)
- Collapse/Expand toggle

**Header:**
- Breadcrumbs (e.g., `Servers > Prod-01 > Terminal`)
- Global search bar (Cmd+K shortcut)
- System status indicator (green/yellow/red)
- Active incidents badge (count)
- User menu (profile, settings, logout)

**Global Status Bar:**
- System health ticker ("System Status: Operational")
- Active incidents count ("Active Incidents: 3")
- Last sync timestamp

**Toast Region:**
- Bottom-right notifications
- Success/Error/Warning/Info variants
- Auto-dismiss after 5s (configurable)
- Action buttons (e.g., "View Details")

**Implementation:**
```typescript
// frontend/src/components/layout/AppShell.tsx
import { Sidebar } from './Sidebar'
import { Header } from './Header'
import { StatusBar } from './StatusBar'
import { Toaster } from '@/components/ui/toaster'

export function AppShell({ children }: { children: React.ReactNode }) {
  const [sidebarOpen, setSidebarOpen] = useState(true)

  return (
    <div className="flex h-screen bg-background">
      <Sidebar open={sidebarOpen} onToggle={setSidebarOpen} />
      <div className="flex-1 flex flex-col overflow-hidden">
        <Header />
        <StatusBar />
        <main className="flex-1 overflow-auto p-6">
          {children}
        </main>
      </div>
      <Toaster />
    </div>
  )
}
```

**RBAC Integration:**
- Hide navigation items based on user permissions
- Example: "Settings" only visible to SUPER_ADMIN, ADMIN
- Example: "Users" only visible to SUPER_ADMIN, ADMIN

---

#### FR-UI-002: Authentication & Route Protection
**Priority:** P0 (Critical)

**Description:** Secure authentication flow with MFA support and route protection.

**Login Flow:**
1. User enters email/password
2. Backend validates credentials (Module 1)
3. If MFA enabled, show TOTP verification
4. On success, store tokens (access in memory, refresh in cookie)
5. Redirect to dashboard

**Token Management:**
```typescript
// frontend/src/lib/auth/tokenManager.ts
class TokenManager {
  private accessToken: string | null = null

  setAccessToken(token: string) {
    this.accessToken = token
  }

  getAccessToken(): string | null {
    return this.accessToken
  }

  clearTokens() {
    this.accessToken = null
    // Refresh token cleared by backend (HTTP-only cookie)
  }
}

export const tokenManager = new TokenManager()
```

**Route Protection:**
```typescript
// frontend/src/middleware.ts
import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'

export function middleware(request: NextRequest) {
  const token = request.cookies.get('refreshToken')
  
  if (!token && !request.nextUrl.pathname.startsWith('/login')) {
    return NextResponse.redirect(new URL('/login', request.url))
  }
  
  return NextResponse.next()
}

export const config = {
  matcher: ['/((?!api|_next/static|_next/image|favicon.ico).*)']
}
```

**RBAC Enforcement:**
```typescript
// frontend/src/components/auth/PermissionGuard.tsx
interface PermissionGuardProps {
  permissions: string[]
  children: React.ReactNode
  fallback?: React.ReactNode
}

export function PermissionGuard({ permissions, children, fallback }: PermissionGuardProps) {
  const { user } = useAuth()
  
  const hasPermission = permissions.some(permission => 
    user?.permissions?.includes(permission)
  )
  
  if (!hasPermission) {
    return fallback || null
  }
  
  return <>{children}</>
}
```

---

### 3.2 NOC Dashboard

#### FR-UI-003: Main Dashboard Widget Grid
**Priority:** P0 (Critical)

**Description:** Landing page summarizing system health with real-time updates.

**Widgets:**

**1. System Health Score:**
- Large gauge (0-100%) based on asset health ratio
- Color-coded: Green (>90%), Yellow (70-90%), Red (<70%)
- Trend indicator (up/down arrow)
- Click to view detailed health report

**2. Incident Feed:**
- Top 5 open incidents sorted by severity
- Severity badges (Critical, High, Medium, Low)
- Time since creation (relative time)
- Assigned user avatar
- Click to open incident detail

**3. Server Utilization:**
- Bar charts for CPU/RAM of top 5 loaded servers
- Real-time updates (polling every 30s)
- Threshold indicators (warning at 80%, critical at 90%)
- Click to open server detail

**4. Recent Automations:**
- Last 10 playbook executions
- Status indicators (Success, Failed, Running)
- Execution duration
- Click to view execution logs

**5. Asset Summary:**
- Total assets by type (Sites, Domains, Databases, SSL)
- Health distribution (Healthy, Warning, Critical)
- Discovery status (Last scan time)

**6. Active Alerts:**
- Current system alerts
- Alert type and severity
- Acknowledgement status
- Quick action buttons

**Implementation:**
```typescript
// frontend/src/app/(dashboard)/dashboard/page.tsx
import { SystemHealthWidget } from '@/components/dashboard/SystemHealthWidget'
import { IncidentFeedWidget } from '@/components/dashboard/IncidentFeedWidget'
import { ServerUtilizationWidget } from '@/components/dashboard/ServerUtilizationWidget'
import { RecentAutomationsWidget } from '@/components/dashboard/RecentAutomationsWidget'
import { AssetSummaryWidget } from '@/components/dashboard/AssetSummaryWidget'
import { ActiveAlertsWidget } from '@/components/dashboard/ActiveAlertsWidget'

export default function DashboardPage() {
  return (
    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
      <div className="col-span-full lg:col-span-2">
        <SystemHealthWidget />
      </div>
      <div className="col-span-full lg:col-span-1">
        <IncidentFeedWidget />
      </div>
      <div className="col-span-full md:col-span-1">
        <ServerUtilizationWidget />
      </div>
      <div className="col-span-full md:col-span-1">
        <RecentAutomationsWidget />
      </div>
      <div className="col-span-full md:col-span-1">
        <AssetSummaryWidget />
      </div>
      <div className="col-span-full">
        <ActiveAlertsWidget />
      </div>
    </div>
  )
}
```

**Real-Time Updates:**
```typescript
// frontend/src/components/dashboard/SystemHealthWidget.tsx
import { useQuery } from '@tanstack/react-query'
import { getSystemHealth } from '@/lib/api/dashboard'

export function SystemHealthWidget() {
  const { data, isLoading } = useQuery({
    queryKey: ['system-health'],
    queryFn: getSystemHealth,
    refetchInterval: 30000, // Poll every 30s
    staleTime: 20000
  })

  if (isLoading) return <WidgetSkeleton />

  return (
    <Card>
      <CardHeader>
        <CardTitle>System Health</CardTitle>
      </CardHeader>
      <CardContent>
        <div className="flex items-center justify-center">
          <GaugeChart value={data.healthScore} />
        </div>
        <div className="mt-4 grid grid-cols-3 gap-4">
          <MetricCard label="Healthy" value={data.healthy} color="green" />
          <MetricCard label="Warning" value={data.warning} color="yellow" />
          <MetricCard label="Critical" value={data.critical} color="red" />
        </div>
      </CardContent>
    </Card>
  )
}
```

---

### 3.3 Resource Management Views

#### FR-UI-004: Server Manager (Module 2 UI)
**Priority:** P0 (Critical)

**List View:**

**Features:**
- Data table with sorting, filtering, pagination
- Columns: Status, Name, IP Address, OS, Environment, Tags, Last Test, Actions
- Filters: Environment (Prod/Staging/Dev), Platform (Linux/Windows), Status (Connected/Disconnected)
- Bulk actions: Test Connection, Delete (with confirmation)
- Search: Real-time search by name, IP, tags
- Export: CSV export functionality

**Actions:**
- Test Connection (triggers Module 2 connection test)
- SSH Terminal (opens modal with terminal emulator)
- Edit (navigates to edit page)
- Delete (confirmation dialog, checks dependencies)

**Implementation:**
```typescript
// frontend/src/app/(dashboard)/servers/page.tsx
import { useQuery } from '@tanstack/react-query'
import { getServers } from '@/lib/api/servers'
import { DataTable } from '@/components/ui/data-table'
import { serverColumns } from './columns'

export default function ServersPage() {
  const [filters, setFilters] = useState({
    environment: null,
    platform: null,
    search: ''
  })

  const { data, isLoading } = useQuery({
    queryKey: ['servers', filters],
    queryFn: () => getServers(filters)
  })

  return (
    <div className="space-y-6">
      <div className="flex items-center justify-between">
        <h1 className="text-3xl font-bold">Servers</h1>
        <PermissionGuard permissions={['servers.create']}>
          <Button asChild>
            <Link href="/servers/new">
              <Plus className="h-4 w-4 mr-2" />
              Add Server
            </Link>
          </Button>
        </PermissionGuard>
      </div>

      <ServerFilters filters={filters} onChange={setFilters} />

      <DataTable
        columns={serverColumns}
        data={data?.servers || []}
        isLoading={isLoading}
        pagination={data?.pagination}
      />
    </div>
  )
}
```

**Detail View:**

**Tabs:**
1. **Overview:** Connection details, credentials (masked), host keys, metadata
2. **Terminal:** SSH terminal emulator (future: WebSocket-based)
3. **Processes:** Running processes list (future enhancement)
4. **Audit Log:** Server-specific audit events

**Connection Widget:**
- Live status indicator (green/red/yellow)
- Last test timestamp
- Test connection button
- Connection details (latency, authentication method)

**Terminal Modal:**
```typescript
// frontend/src/components/servers/TerminalModal.tsx
import { useState } from 'react'
import { Dialog, DialogContent, DialogHeader, DialogTitle } from '@/components/ui/dialog'
import { Input } from '@/components/ui/input'
import { Button } from '@/components/ui/button'
import { executeCommand } from '@/lib/api/servers'

export function TerminalModal({ serverId, open, onClose }: TerminalModalProps) {
  const [command, setCommand] = useState('')
  const [output, setOutput] = useState<string[]>([])
  const [isExecuting, setIsExecuting] = useState(false)

  const handleExecute = async () => {
    if (!command.trim()) return

    setIsExecuting(true)
    setOutput(prev => [...prev, `$ ${command}`])

    try {
      const result = await executeCommand(serverId, command)
      setOutput(prev => [...prev, result.stdout || result.stderr])
    } catch (error) {
      setOutput(prev => [...prev, `Error: ${error.message}`])
    } finally {
      setIsExecuting(false)
      setCommand('')
    }
  }

  return (
    <Dialog open={open} onOpenChange={onClose}>
      <DialogContent className="max-w-4xl h-[600px]">
        <DialogHeader>
          <DialogTitle>SSH Terminal</DialogTitle>
        </DialogHeader>
        <div className="flex-1 bg-black text-green-400 font-mono text-sm p-4 overflow-auto">
          {output.map((line, i) => (
            <div key={i}>{line}</div>
          ))}
        </div>
        <div className="flex gap-2">
          <Input
            value={command}
            onChange={(e) => setCommand(e.target.value)}
            onKeyDown={(e) => e.key === 'Enter' && handleExecute()}
            placeholder="Enter command..."
            disabled={isExecuting}
            className="font-mono"
          />
          <Button onClick={handleExecute} disabled={isExecuting}>
            Execute
          </Button>
        </div>
      </DialogContent>
    </Dialog>
  )
}
```

---

#### FR-UI-005: Asset Registry (Module 4 UI)
**Priority:** P1 (High)

**List View:**

**Features:**
- View toggle: Table view / Grid view
- Filters: Type (Site, Domain, Database, SSL), Status (Healthy, Warning, Critical), Server
- Search: Real-time search by name, domain, metadata
- Bulk actions: Health check, Delete (with confirmation)
- Export: CSV export functionality

**Grid View:**
- Card-based layout with screenshots (placeholders)
- Asset type icon
- Health status badge
- Quick actions (View, Edit, Health Check)

**Implementation:**
```typescript
// frontend/src/app/(dashboard)/assets/page.tsx
import { useState } from 'react'
import { useQuery } from '@tanstack/react-query'
import { getAssets } from '@/lib/api/assets'
import { DataTable } from '@/components/ui/data-table'
import { AssetGrid } from '@/components/assets/AssetGrid'
import { assetColumns } from './columns'

export default function AssetsPage() {
  const [viewMode, setViewMode] = useState<'table' | 'grid'>('table')
  const [filters, setFilters] = useState({
    type: null,
    status: null,
    search: ''
  })

  const { data, isLoading } = useQuery({
    queryKey: ['assets', filters],
    queryFn: () => getAssets(filters)
  })

  return (
    <div className="space-y-6">
      <div className="flex items-center justify-between">
        <h1 className="text-3xl font-bold">Assets</h1>
        <div className="flex items-center gap-2">
          <ViewToggle value={viewMode} onChange={setViewMode} />
          <Button onClick={() => triggerDiscovery()}>
            <RefreshCw className="h-4 w-4 mr-2" />
            Discover Assets
          </Button>
        </div>
      </div>

      <AssetFilters filters={filters} onChange={setFilters} />

      {viewMode === 'table' ? (
        <DataTable
          columns={assetColumns}
          data={data?.assets || []}
          isLoading={isLoading}
        />
      ) : (
        <AssetGrid assets={data?.assets || []} isLoading={isLoading} />
      )}
    </div>
  )
}
```

**Detail View:**

**Header:**
- Asset name/domain
- Health badge (Green/Yellow/Red)
- Asset type icon
- Quick actions (Edit, Health Check, Delete)

**Metadata Panel:**
- Asset-specific metadata (WordPress version, PHP version, SSL expiry, etc.)
- Server relationship
- Discovery information (last scan, method)

**Relations Graph:**
```typescript
// frontend/src/components/assets/RelationsGraph.tsx
import ReactFlow, { Node, Edge } from 'reactflow'
import 'reactflow/dist/style.css'

export function RelationsGraph({ assetId }: { assetId: string }) {
  const { data } = useQuery({
    queryKey: ['asset-relations', assetId],
    queryFn: () => getAssetRelations(assetId)
  })

  const nodes: Node[] = [
    { id: 'server', data: { label: 'Server: Prod-01' }, position: { x: 0, y: 0 } },
    { id: 'site', data: { label: 'Site: example.com' }, position: { x: 200, y: 0 } },
    { id: 'db', data: { label: 'DB: example_db' }, position: { x: 400, y: 0 } }
  ]

  const edges: Edge[] = [
    { id: 'e1', source: 'server', target: 'site', label: 'hosts' },
    { id: 'e2', source: 'site', target: 'db', label: 'uses' }
  ]

  return (
    <div className="h-[400px] border rounded-lg">
      <ReactFlow nodes={nodes} edges={edges} fitView />
    </div>
  )
}
```

---

### 3.4 Incident Response Center

#### FR-UI-006: Incident Kanban Board (Module 6 UI)
**Priority:** P1 (High)

**Description:** Visualizing incident lifecycle with drag-and-drop state management.

**Views:**

**List View:**
- Standard sortable table
- Columns: ID, Title, Severity, Status, Assigned To, Created At, Updated At, Actions
- Filters: Severity, Status, Assigned User, Date Range
- Search: Real-time search by title, description
- Bulk actions: Assign, Change Status, Close

**Kanban View:**
- Columns: NEW, INVESTIGATING, FIX_IN_PROGRESS, RESOLVED
- Drag-and-drop to change status (triggers Module 6 state transition)
- Card displays: Title, Severity badge, Assigned user avatar, Time since creation
- Column counts and severity distribution

**Implementation:**
```typescript
// frontend/src/app/(dashboard)/incidents/page.tsx
import { useState } from 'react'
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query'
import { getIncidents, updateIncidentStatus } from '@/lib/api/incidents'
import { IncidentKanban } from '@/components/incidents/IncidentKanban'
import { DataTable } from '@/components/ui/data-table'
import { incidentColumns } from './columns'

export default function IncidentsPage() {
  const [viewMode, setViewMode] = useState<'list' | 'kanban'>('kanban')
  const queryClient = useQueryClient()

  const { data, isLoading } = useQuery({
    queryKey: ['incidents'],
    queryFn: getIncidents,
    refetchInterval: 5000 // Poll every 5s for real-time updates
  })

  const updateStatusMutation = useMutation({
    mutationFn: ({ id, status }: { id: string; status: string }) =>
      updateIncidentStatus(id, status),
    onMutate: async ({ id, status }) => {
      // Optimistic update
      await queryClient.cancelQueries({ queryKey: ['incidents'] })
      const previous = queryClient.getQueryData(['incidents'])
      
      queryClient.setQueryData(['incidents'], (old: any) => ({
        ...old,
        incidents: old.incidents.map((inc: any) =>
          inc.id === id ? { ...inc, status } : inc
        )
      }))
      
      return { previous }
    },
    onError: (err, variables, context) => {
      // Rollback on error
      queryClient.setQueryData(['incidents'], context?.previous)
    },
    onSettled: () => {
      queryClient.invalidateQueries({ queryKey: ['incidents'] })
    }
  })

  return (
    <div className="space-y-6">
      <div className="flex items-center justify-between">
        <h1 className="text-3xl font-bold">Incidents</h1>
        <div className="flex items-center gap-2">
          <ViewToggle value={viewMode} onChange={setViewMode} />
          <PermissionGuard permissions={['incidents.create']}>
            <Button asChild>
              <Link href="/incidents/new">
                <Plus className="h-4 w-4 mr-2" />
                Create Incident
              </Link>
            </Button>
          </PermissionGuard>
        </div>
      </div>

      {viewMode === 'kanban' ? (
        <IncidentKanban
          incidents={data?.incidents || []}
          onStatusChange={(id, status) => updateStatusMutation.mutate({ id, status })}
        />
      ) : (
        <DataTable
          columns={incidentColumns}
          data={data?.incidents || []}
          isLoading={isLoading}
        />
      )}
    </div>
  )
}
```

**Kanban Board Component:**
```typescript
// frontend/src/components/incidents/IncidentKanban.tsx
import { DndContext, DragEndEvent } from '@dnd-kit/core'
import { KanbanColumn } from './KanbanColumn'
import { IncidentCard } from './IncidentCard'

const COLUMNS = [
  { id: 'NEW', title: 'New', color: 'blue' },
  { id: 'INVESTIGATING', title: 'Investigating', color: 'yellow' },
  { id: 'FIX_IN_PROGRESS', title: 'Fix In Progress', color: 'orange' },
  { id: 'RESOLVED', title: 'Resolved', color: 'green' }
]

export function IncidentKanban({ incidents, onStatusChange }: IncidentKanbanProps) {
  const handleDragEnd = (event: DragEndEvent) => {
    const { active, over } = event
    if (!over || active.id === over.id) return

    const incidentId = active.id as string
    const newStatus = over.id as string

    onStatusChange(incidentId, newStatus)
  }

  return (
    <DndContext onDragEnd={handleDragEnd}>
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
        {COLUMNS.map(column => (
          <KanbanColumn
            key={column.id}
            id={column.id}
            title={column.title}
            color={column.color}
            incidents={incidents.filter(inc => inc.status === column.id)}
          />
        ))}
      </div>
    </DndContext>
  )
}
```

**Detail View (War Room):**

**Timeline:**
- Chat-like history of events (Module 6 timeline)
- Event types: Status Change, Comment, Playbook Execution, Assignment
- User avatars and timestamps
- Expandable event details

**Action Bar:**
- Trigger playbooks (Module 5 integration)
- Assign to user
- Change severity
- Change status
- Close incident

**Comment Box:**
```typescript
// frontend/src/components/incidents/CommentBox.tsx
import { useState } from 'react'
import { useMutation, useQueryClient } from '@tanstack/react-query'
import { addIncidentComment } from '@/lib/api/incidents'
import { Textarea } from '@/components/ui/textarea'
import { Button } from '@/components/ui/button'

export function CommentBox({ incidentId }: { incidentId: string }) {
  const [comment, setComment] = useState('')
  const queryClient = useQueryClient()

  const addCommentMutation = useMutation({
    mutationFn: (content: string) => addIncidentComment(incidentId, content),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['incident', incidentId] })
      setComment('')
    }
  })

  return (
    <div className="space-y-2">
      <Textarea
        value={comment}
        onChange={(e) => setComment(e.target.value)}
        placeholder="Add a comment..."
        rows={3}
      />
      <Button
        onClick={() => addCommentMutation.mutate(comment)}
        disabled={!comment.trim() || addCommentMutation.isPending}
      >
        Add Comment
      </Button>
    </div>
  )
}
```

---

### 3.5 Automation Hub

#### FR-UI-007: Playbook Runner (Module 5 UI)
**Priority:** P1 (High)

**Description:** Interface to manually trigger automation playbooks and view execution history.

**Playbook Library:**
- Card-based layout
- Playbook name, description, icon
- Tags (category, risk level)
- Execution count and success rate
- "Run Playbook" button

**Execution Form:**
- Dynamic form based on playbook parameters
- Server selection (dropdown with search)
- Parameter inputs (text, number, boolean, select)
- Dry-run option (preview without execution)
- Confirmation dialog for destructive operations

**Implementation:**
```typescript
// frontend/src/app/(dashboard)/automations/page.tsx
import { useQuery } from '@tanstack/react-query'
import { getPlaybooks } from '@/lib/api/automations'
import { PlaybookCard } from '@/components/automations/PlaybookCard'
import { PlaybookExecutionModal } from '@/components/automations/PlaybookExecutionModal'

export default function AutomationsPage() {
  const [selectedPlaybook, setSelectedPlaybook] = useState<Playbook | null>(null)

  const { data, isLoading } = useQuery({
    queryKey: ['playbooks'],
    queryFn: getPlaybooks
  })

  return (
    <div className="space-y-6">
      <div className="flex items-center justify-between">
        <h1 className="text-3xl font-bold">Automations</h1>
        <Button asChild>
          <Link href="/automations/history">
            <History className="h-4 w-4 mr-2" />
            Execution History
          </Link>
        </Button>
      </div>

      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
        {data?.playbooks.map(playbook => (
          <PlaybookCard
            key={playbook.id}
            playbook={playbook}
            onRun={() => setSelectedPlaybook(playbook)}
          />
        ))}
      </div>

      {selectedPlaybook && (
        <PlaybookExecutionModal
          playbook={selectedPlaybook}
          open={!!selectedPlaybook}
          onClose={() => setSelectedPlaybook(null)}
        />
      )}
    </div>
  )
}
```

**Execution History:**
- Table with columns: Playbook, Server, Status, Duration, Started At, User, Actions
- Filters: Status (Success, Failed, Running), Playbook, Date Range
- "View Logs" button opens log viewer modal

**Log Viewer Modal:**
```typescript
// frontend/src/components/automations/LogViewerModal.tsx
import { useQuery } from '@tanstack/react-query'
import { getExecutionLogs } from '@/lib/api/automations'
import { Dialog, DialogContent, DialogHeader, DialogTitle } from '@/components/ui/dialog'
import { ScrollArea } from '@/components/ui/scroll-area'

export function LogViewerModal({ executionId, open, onClose }: LogViewerModalProps) {
  const { data, isLoading } = useQuery({
    queryKey: ['execution-logs', executionId],
    queryFn: () => getExecutionLogs(executionId),
    enabled: open
  })

  return (
    <Dialog open={open} onOpenChange={onClose}>
      <DialogContent className="max-w-4xl h-[600px]">
        <DialogHeader>
          <DialogTitle>Execution Logs</DialogTitle>
        </DialogHeader>
        <ScrollArea className="flex-1 bg-black text-green-400 font-mono text-sm p-4">
          {isLoading ? (
            <div>Loading logs...</div>
          ) : (
            data?.logs.map((log, i) => (
              <div key={i} className="whitespace-pre-wrap">
                <span className="text-gray-500">[{log.timestamp}]</span>{' '}
                <span className={getLogColor(log.level)}>{log.message}</span>
              </div>
            ))
          )}
        </ScrollArea>
      </DialogContent>
    </Dialog>
  )
}

function getLogColor(level: string) {
  switch (level) {
    case 'ERROR': return 'text-red-400'
    case 'WARN': return 'text-yellow-400'
    case 'INFO': return 'text-blue-400'
    default: return 'text-green-400'
  }
}
```

---

### 3.6 Settings & Configuration

#### FR-UI-008: System Configuration
**Priority:** P1 (High)

**Description:** Centralized settings and configuration management.

**Tabs:**

**1. Integrations (Module 3):**
- List of configured integrations (WHM, WHMCS, Git, etc.)
- Add integration button
- Integration cards with: Name, Type, Status, Last Sync, Actions
- Configuration form: URL, API Key, Test Connection button
- Test results display (success/failure with details)

**Implementation:**
```typescript
// frontend/src/app/(dashboard)/settings/integrations/page.tsx
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query'
import { getIntegrations, testIntegration } from '@/lib/api/integrations'
import { IntegrationCard } from '@/components/settings/IntegrationCard'

export default function IntegrationsPage() {
  const queryClient = useQueryClient()

  const { data, isLoading } = useQuery({
    queryKey: ['integrations'],
    queryFn: getIntegrations
  })

  const testMutation = useMutation({
    mutationFn: (id: string) => testIntegration(id),
    onSuccess: (result, id) => {
      toast({
        title: result.success ? 'Connection Successful' : 'Connection Failed',
        description: result.message,
        variant: result.success ? 'default' : 'destructive'
      })
    }
  })

  return (
    <div className="space-y-6">
      <div className="flex items-center justify-between">
        <h1 className="text-3xl font-bold">Integrations</h1>
        <PermissionGuard permissions={['integrations.create']}>
          <Button asChild>
            <Link href="/settings/integrations/new">
              <Plus className="h-4 w-4 mr-2" />
              Add Integration
            </Link>
          </Button>
        </PermissionGuard>
      </div>

      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
        {data?.integrations.map(integration => (
          <IntegrationCard
            key={integration.id}
            integration={integration}
            onTest={() => testMutation.mutate(integration.id)}
          />
        ))}
      </div>
    </div>
  )
}
```

**2. Notification Rules (Module 8):**
- Rule builder interface
- Condition editor: "If Severity > High AND Type = Server Down"
- Action editor: "Then Send to Slack #alerts AND Email ops@company.com"
- Rule list with enable/disable toggle
- Test rule button (sends test notification)

**3. Users & Roles (Module 1):**
- User management table
- Columns: Name, Email, Role, Status, Last Login, Actions
- Add user button (opens form modal)
- Edit user (inline or modal)
- Delete user (confirmation dialog)
- Role assignment dropdown
- Permission matrix viewer (read-only)

**4. Audit Logs (Module 7):**
- Searchable, filterable table
- Columns: Timestamp, User, Action, Resource, Result, Details
- Filters: Date Range, User, Action Type, Result (Success/Failure)
- Search: Full-text search across all fields
- JSON viewer for event details (expandable row)

```typescript
// frontend/src/app/(dashboard)/settings/audit-logs/page.tsx
import { useState } from 'react'
import { useQuery } from '@tanstack/react-query'
import { getAuditLogs } from '@/lib/api/audit'
import { DataTable } from '@/components/ui/data-table'
import { auditLogColumns } from './columns'
import { AuditLogFilters } from '@/components/audit/AuditLogFilters'

export default function AuditLogsPage() {
  const [filters, setFilters] = useState({
    dateRange: { from: null, to: null },
    user: null,
    action: null,
    result: null,
    search: ''
  })

  const { data, isLoading } = useQuery({
    queryKey: ['audit-logs', filters],
    queryFn: () => getAuditLogs(filters)
  })

  return (
    <div className="space-y-6">
      <h1 className="text-3xl font-bold">Audit Logs</h1>

      <AuditLogFilters filters={filters} onChange={setFilters} />

      <DataTable
        columns={auditLogColumns}
        data={data?.logs || []}
        isLoading={isLoading}
        pagination={data?.pagination}
        expandable={(row) => (
          <pre className="bg-muted p-4 rounded-lg overflow-auto">
            {JSON.stringify(row.details, null, 2)}
          </pre>
        )}
      />
    </div>
  )
}
```

---

## 4. Technical Architecture

### 4.1 Component Hierarchy (Atomic Design)

**Atoms (shadcn/ui primitives):**
- Button, Input, Textarea, Select, Checkbox, Radio
- Badge, Avatar, Separator, Skeleton
- Alert, Toast, Tooltip, Popover

**Molecules (Composite UI elements):**
- `ServerStatusBadge` - Connection status indicator
- `IncidentRow` - Incident list item
- `LogViewer` - Syntax-highlighted log display
- `MetricCard` - Dashboard metric display
- `FilterBar` - Search and filter controls
- `ActionMenu` - Dropdown action menu

**Organisms (Complex components):**
- `ServerTable` - Server list with actions
- `IncidentKanban` - Drag-and-drop board
- `PlaybookRunner` - Automation execution interface
- `AssetGrid` - Asset card grid
- `AuditLogTable` - Searchable audit log
- `NotificationRuleBuilder` - Rule configuration UI

**Templates (Page layouts):**
- `ResourceLayout` - Standard resource page layout
- `DashboardLayout` - Dashboard grid layout
- `DetailLayout` - Resource detail page layout
- `SettingsLayout` - Settings page with tabs

**Pages (Next.js App Router):**
- `/login` - Authentication
- `/dashboard` - NOC dashboard
- `/servers` - Server management
- `/assets` - Asset registry
- `/incidents` - Incident response
- `/automations` - Playbook runner
- `/settings/*` - Configuration pages

---

### 4.2 State Management Architecture

#### Global State (Zustand)
```typescript
// frontend/src/lib/store/appStore.ts
import { create } from 'zustand'
import { persist } from 'zustand/middleware'

interface AppState {
  // User state
  currentUser: User | null
  setCurrentUser: (user: User | null) => void
  
  // UI state
  sidebarOpen: boolean
  toggleSidebar: () => void
  
  // System state
  activeIncidentsCount: number
  setActiveIncidentsCount: (count: number) => void
  
  // Notifications
  notifications: Notification[]
  addNotification: (notification: Notification) => void
  removeNotification: (id: string) => void
}

export const useAppStore = create<AppState>()(
  persist(
    (set) => ({
      currentUser: null,
      setCurrentUser: (user) => set({ currentUser: user }),
      
      sidebarOpen: true,
      toggleSidebar: () => set((state) => ({ sidebarOpen: !state.sidebarOpen })),
      
      activeIncidentsCount: 0,
      setActiveIncidentsCount: (count) => set({ activeIncidentsCount: count }),
      
      notifications: [],
      addNotification: (notification) =>
        set((state) => ({ notifications: [...state.notifications, notification] })),
      removeNotification: (id) =>
        set((state) => ({
          notifications: state.notifications.filter((n) => n.id !== id)
        }))
    }),
    {
      name: 'app-storage',
      partialize: (state) => ({ sidebarOpen: state.sidebarOpen })
    }
  )
)
```

#### Server State (React Query)
```typescript
// frontend/src/lib/api/hooks/useServers.ts
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query'
import { getServers, createServer, updateServer, deleteServer } from '../servers'

export function useServers(filters?: ServerFilters) {
  return useQuery({
    queryKey: ['servers', filters],
    queryFn: () => getServers(filters),
    staleTime: 30000, // Cache for 30s
    refetchOnWindowFocus: true
  })
}

export function useServer(id: string) {
  return useQuery({
    queryKey: ['server', id],
    queryFn: () => getServer(id),
    enabled: !!id
  })
}

export function useCreateServer() {
  const queryClient = useQueryClient()
  
  return useMutation({
    mutationFn: createServer,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['servers'] })
      toast({ title: 'Server created successfully' })
    },
    onError: (error: any) => {
      toast({
        title: 'Failed to create server',
        description: error.response?.data?.message,
        variant: 'destructive'
      })
    }
  })
}

export function useUpdateServer() {
  const queryClient = useQueryClient()
  
  return useMutation({
    mutationFn: ({ id, data }: { id: string; data: UpdateServerDto }) =>
      updateServer(id, data),
    onMutate: async ({ id, data }) => {
      // Optimistic update
      await queryClient.cancelQueries({ queryKey: ['server', id] })
      const previous = queryClient.getQueryData(['server', id])
      
      queryClient.setQueryData(['server', id], (old: any) => ({
        ...old,
        ...data
      }))
      
      return { previous }
    },
    onError: (err, variables, context) => {
      queryClient.setQueryData(['server', variables.id], context?.previous)
    },
    onSettled: (data, error, variables) => {
      queryClient.invalidateQueries({ queryKey: ['server', variables.id] })
      queryClient.invalidateQueries({ queryKey: ['servers'] })
    }
  })
}
```

#### Form State (React Hook Form + Zod)
```typescript
// frontend/src/lib/validations/server.ts
import { z } from 'zod'

export const serverSchema = z.object({
  name: z.string().min(3).max(100),
  host: z.string().min(1),
  port: z.number().min(1).max(65535),
  username: z.string().min(1),
  platformType: z.enum(['LINUX', 'WINDOWS']),
  environment: z.enum(['PROD', 'STAGING', 'DEV']).nullable(),
  authType: z.enum(['SSH_KEY', 'SSH_KEY_WITH_PASSPHRASE', 'PASSWORD']),
  credentials: z.object({
    privateKey: z.string().optional(),
    passphrase: z.string().optional(),
    password: z.string().optional()
  }),
  privilegeMode: z.enum(['ROOT', 'SUDO', 'USER_ONLY']),
  sudoMode: z.enum(['NONE', 'NOPASSWD', 'PASSWORD_REQUIRED']),
  hostKeyStrategy: z.enum(['STRICT_PINNED', 'TOFU', 'DISABLED']),
  tags: z.array(z.string()).optional(),
  notes: z.string().max(1000).optional()
})

export type ServerFormData = z.infer<typeof serverSchema>
```

```typescript
// frontend/src/components/servers/ServerForm.tsx
import { useForm } from 'react-hook-form'
import { zodResolver } from '@hookform/resolvers/zod'
import { serverSchema, ServerFormData } from '@/lib/validations/server'

export function ServerForm({ initialData, onSubmit }: ServerFormProps) {
  const form = useForm<ServerFormData>({
    resolver: zodResolver(serverSchema),
    defaultValues: initialData || {
      name: '',
      host: '',
      port: 22,
      username: 'root',
      platformType: 'LINUX',
      environment: null,
      authType: 'SSH_KEY',
      privilegeMode: 'SUDO',
      sudoMode: 'NOPASSWD',
      hostKeyStrategy: 'STRICT_PINNED',
      tags: [],
      notes: ''
    }
  })

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-6">
        {/* Form fields */}
      </form>
    </Form>
  )
}
```

---

### 4.3 Data Fetching Strategy

#### Polling for Real-Time Updates
```typescript
// Incidents poll every 5s when not resolved
export function useIncident(id: string) {
  return useQuery({
    queryKey: ['incident', id],
    queryFn: () => getIncident(id),
    refetchInterval: (data) => {
      return data?.status === 'RESOLVED' ? false : 5000
    }
  })
}

// Dashboard widgets poll every 30s
export function useSystemHealth() {
  return useQuery({
    queryKey: ['system-health'],
    queryFn: getSystemHealth,
    refetchInterval: 30000,
    staleTime: 20000
  })
}
```

#### Optimistic Updates
```typescript
// Optimistic UI for instant feedback
export function useDeleteServer() {
  const queryClient = useQueryClient()
  
  return useMutation({
    mutationFn: deleteServer,
    onMutate: async (id) => {
      await queryClient.cancelQueries({ queryKey: ['servers'] })
      const previous = queryClient.getQueryData(['servers'])
      
      // Optimistically remove from list
      queryClient.setQueryData(['servers'], (old: any) => ({
        ...old,
        servers: old.servers.filter((s: any) => s.id !== id)
      }))
      
      return { previous }
    },
    onError: (err, id, context) => {
      // Rollback on error
      queryClient.setQueryData(['servers'], context?.previous)
      toast({
        title: 'Failed to delete server',
        description: err.message,
        variant: 'destructive'
      })
    },
    onSuccess: () => {
      toast({ title: 'Server deleted successfully' })
    }
  })
}
```

#### Prefetching
```typescript
// Prefetch detail page on hover
export function ServerRow({ server }: { server: Server }) {
  const queryClient = useQueryClient()
  
  const handleMouseEnter = () => {
    queryClient.prefetchQuery({
      queryKey: ['server', server.id],
      queryFn: () => getServer(server.id)
    })
  }
  
  return (
    <TableRow onMouseEnter={handleMouseEnter}>
      {/* Row content */}
    </TableRow>
  )
}
```



---

### 4.4 API Integration Layer

#### Centralized API Client
```typescript
// frontend/src/lib/api/client.ts
import axios, { AxiosError, AxiosRequestConfig } from 'axios'
import { tokenManager } from '../auth/tokenManager'

const API_BASE_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:3001/api/v1'

export const apiClient = axios.create({
  baseURL: API_BASE_URL,
  timeout: 30000,
  headers: {
    'Content-Type': 'application/json'
  },
  withCredentials: true // Include cookies for refresh token
})

// Request interceptor - inject access token
apiClient.interceptors.request.use(
  (config) => {
    const token = tokenManager.getAccessToken()
    if (token) {
      config.headers.Authorization = `Bearer ${token}`
    }
    return config
  },
  (error) => Promise.reject(error)
)

// Response interceptor - handle errors and token refresh
apiClient.interceptors.response.use(
  (response) => response,
  async (error: AxiosError) => {
    const originalRequest = error.config as AxiosRequestConfig & { _retry?: boolean }

    // Handle 401 Unauthorized
    if (error.response?.status === 401 && !originalRequest._retry) {
      originalRequest._retry = true

      try {
        // Attempt token refresh
        const { data } = await axios.post(
          `${API_BASE_URL}/auth/refresh`,
          {},
          { withCredentials: true }
        )

        tokenManager.setAccessToken(data.accessToken)

        // Retry original request with new token
        if (originalRequest.headers) {
          originalRequest.headers.Authorization = `Bearer ${data.accessToken}`
        }
        return apiClient(originalRequest)
      } catch (refreshError) {
        // Refresh failed - redirect to login
        tokenManager.clearTokens()
        window.location.href = '/login'
        return Promise.reject(refreshError)
      }
    }

    // Handle other errors
    if (error.response?.status === 403) {
      toast({
        title: 'Access Denied',
        description: 'You do not have permission to perform this action',
        variant: 'destructive'
      })
    }

    return Promise.reject(error)
  }
)
```

#### Type-Safe API Functions
```typescript
// frontend/src/lib/api/servers.ts
import { apiClient } from './client'
import type { Server, CreateServerDto, UpdateServerDto, ServerFilters } from '@/types/server'

export async function getServers(filters?: ServerFilters) {
  const { data } = await apiClient.get<{ servers: Server[]; pagination: Pagination }>('/servers', {
    params: filters
  })
  return data
}

export async function getServer(id: string) {
  const { data } = await apiClient.get<Server>(`/servers/${id}`)
  return data
}

export async function createServer(dto: CreateServerDto) {
  const { data } = await apiClient.post<Server>('/servers', dto)
  return data
}

export async function updateServer(id: string, dto: UpdateServerDto) {
  const { data } = await apiClient.patch<Server>(`/servers/${id}`, dto)
  return data
}

export async function deleteServer(id: string) {
  await apiClient.delete(`/servers/${id}`)
}

export async function testServerConnection(id: string) {
  const { data } = await apiClient.post<ConnectionTestResult>(`/servers/${id}/test`)
  return data
}

export async function executeCommand(id: string, command: string) {
  const { data } = await apiClient.post<CommandResult>(`/servers/${id}/exec`, { command })
  return data
}
```

#### Shared TypeScript Types
```typescript
// frontend/src/types/server.ts
// These types should match backend DTOs exactly

export interface Server {
  id: string
  name: string
  host: string
  port: number
  username: string
  platformType: 'LINUX' | 'WINDOWS'
  environment: 'PROD' | 'STAGING' | 'DEV' | null
  connectionProtocol: 'SSH'
  authType: 'SSH_KEY' | 'SSH_KEY_WITH_PASSPHRASE' | 'PASSWORD'
  privilegeMode: 'ROOT' | 'SUDO' | 'USER_ONLY'
  sudoMode: 'NONE' | 'NOPASSWD' | 'PASSWORD_REQUIRED'
  hostKeyStrategy: 'STRICT_PINNED' | 'TOFU' | 'DISABLED'
  lastTestStatus: 'NEVER_TESTED' | 'OK' | 'FAILED' | null
  lastTestAt: string | null
  tags: string[]
  notes: string | null
  createdAt: string
  updatedAt: string
  // Note: credentials are NEVER included in responses
}

export interface CreateServerDto {
  name: string
  host: string
  port: number
  username: string
  platformType: 'LINUX' | 'WINDOWS'
  environment?: 'PROD' | 'STAGING' | 'DEV' | null
  connectionProtocol: 'SSH'
  authType: 'SSH_KEY' | 'SSH_KEY_WITH_PASSPHRASE' | 'PASSWORD'
  credentials: {
    privateKey?: string
    passphrase?: string
    password?: string
  }
  privilegeMode: 'ROOT' | 'SUDO' | 'USER_ONLY'
  sudoMode: 'NONE' | 'NOPASSWD' | 'PASSWORD_REQUIRED'
  sudoPassword?: string
  hostKeyStrategy: 'STRICT_PINNED' | 'TOFU' | 'DISABLED'
  knownHostFingerprints?: Array<{
    keyType: string
    fingerprint: string
  }>
  tags?: string[]
  notes?: string
}

export type UpdateServerDto = Partial<CreateServerDto>

export interface ServerFilters {
  page?: number
  limit?: number
  sort?: string
  order?: 'asc' | 'desc'
  search?: string
  platformType?: 'LINUX' | 'WINDOWS'
  environment?: 'PROD' | 'STAGING' | 'DEV'
  tags?: string[]
  lastTestStatus?: 'NEVER_TESTED' | 'OK' | 'FAILED'
}
```

---

### 4.5 Real-Time Communication

#### WebSocket Integration (Future Enhancement)
```typescript
// frontend/src/lib/websocket/client.ts
import { io, Socket } from 'socket.io-client'
import { tokenManager } from '../auth/tokenManager'

class WebSocketClient {
  private socket: Socket | null = null

  connect() {
    const token = tokenManager.getAccessToken()
    
    this.socket = io(process.env.NEXT_PUBLIC_WS_URL || 'http://localhost:3001', {
      auth: { token },
      transports: ['websocket']
    })

    this.socket.on('connect', () => {
      console.log('WebSocket connected')
    })

    this.socket.on('incident:created', (incident) => {
      // Update React Query cache
      queryClient.invalidateQueries({ queryKey: ['incidents'] })
      
      // Show toast notification
      toast({
        title: 'New Incident',
        description: incident.title,
        variant: 'destructive'
      })
    })

    this.socket.on('server:status', (data) => {
      // Update server status in cache
      queryClient.setQueryData(['server', data.serverId], (old: any) => ({
        ...old,
        lastTestStatus: data.status
      }))
    })
  }

  disconnect() {
    this.socket?.disconnect()
  }

  subscribe(event: string, callback: (data: any) => void) {
    this.socket?.on(event, callback)
  }

  unsubscribe(event: string) {
    this.socket?.off(event)
  }
}

export const wsClient = new WebSocketClient()
```

---

## 5. Database Schema

### Frontend Does Not Directly Access Database
The Admin Control Panel is a **pure frontend application** that communicates exclusively with backend APIs (Modules 1-8). All database operations are handled by the backend.

**Data Flow:**
```
Frontend (Next.js) â†’ API Client (Axios) â†’ Backend API (NestJS) â†’ Database (PostgreSQL)
```

**Type Safety:**
- Frontend types mirror backend DTOs
- No direct database access from frontend
- All data validation happens on backend
- Frontend performs client-side validation for UX only

---

## 6. API Specification

### Frontend Consumes Backend APIs

The Admin Control Panel consumes APIs from all backend modules:

**Module 1 (Authentication):**
- `POST /api/v1/auth/login` - User login
- `POST /api/v1/auth/logout` - User logout
- `POST /api/v1/auth/refresh` - Token refresh
- `POST /api/v1/auth/mfa/setup` - MFA setup
- `POST /api/v1/auth/mfa/verify` - MFA verification
- `GET /api/v1/users/me` - Current user profile

**Module 2 (Server Management):**
- `GET /api/v1/servers` - List servers
- `POST /api/v1/servers` - Create server
- `GET /api/v1/servers/:id` - Get server details
- `PATCH /api/v1/servers/:id` - Update server
- `DELETE /api/v1/servers/:id` - Delete server
- `POST /api/v1/servers/:id/test` - Test connection
- `POST /api/v1/servers/:id/exec` - Execute command

**Module 3 (Integration Hub):**
- `GET /api/v1/integrations` - List integrations
- `POST /api/v1/integrations` - Create integration
- `POST /api/v1/integrations/:id/test` - Test integration

**Module 4 (Asset Registry):**
- `GET /api/v1/assets` - List assets
- `GET /api/v1/assets/:id` - Get asset details
- `POST /api/v1/assets/:id/health-check` - Trigger health check
- `GET /api/v1/assets/:id/relations` - Get asset relationships

**Module 5 (Automation):**
- `GET /api/v1/automations/playbooks` - List playbooks
- `POST /api/v1/automations/execute` - Execute playbook
- `GET /api/v1/automations/executions` - Execution history
- `GET /api/v1/automations/executions/:id/logs` - Execution logs

**Module 6 (Incident Management):**
- `GET /api/v1/incidents` - List incidents
- `POST /api/v1/incidents` - Create incident
- `GET /api/v1/incidents/:id` - Get incident details
- `PATCH /api/v1/incidents/:id` - Update incident
- `POST /api/v1/incidents/:id/comments` - Add comment
- `GET /api/v1/incidents/:id/timeline` - Get timeline

**Module 7 (Logging):**
- `GET /api/v1/logs` - Search logs
- `GET /api/v1/audit-logs` - Get audit logs

**Module 8 (Notifications):**
- `GET /api/v1/notifications/channels` - List channels
- `POST /api/v1/notifications/channels` - Create channel
- `GET /api/v1/notifications/rules` - List rules
- `POST /api/v1/notifications/rules` - Create rule

**API Client Pattern:**
```typescript
// All API functions follow this pattern:
export async function apiFunction(params: Params): Promise<Response> {
  const { data } = await apiClient.method<Response>('/endpoint', params)
  return data
}
```

---

## 7. Security Considerations

### 7.1 Authentication & Authorization

**Token Management:**
- Access tokens stored in memory (cleared on page refresh)
- Refresh tokens stored in HTTP-only cookies (secure, not accessible to JavaScript)
- Automatic token refresh on 401 responses
- Token cleared on logout or refresh failure

**RBAC Enforcement:**
```typescript
// Hide UI elements based on permissions
<PermissionGuard permissions={['servers.create']}>
  <Button>Add Server</Button>
</PermissionGuard>

// Protect entire pages
export default function UsersPage() {
  const { user } = useAuth()
  
  if (!user?.permissions?.includes('users.read')) {
    return <AccessDenied />
  }
  
  return <UserManagement />
}
```

**Route Protection:**
- Middleware checks for refresh token cookie
- Redirects to login if missing
- Protected routes require authentication
- Permission checks on sensitive pages

---

### 7.2 Input Validation

**Client-Side Validation (UX):**
```typescript
// Zod schema for immediate feedback
const serverSchema = z.object({
  name: z.string().min(3, 'Name must be at least 3 characters'),
  host: z.string().min(1, 'Host is required'),
  port: z.number().min(1).max(65535, 'Port must be between 1 and 65535')
})

// React Hook Form integration
const form = useForm({
  resolver: zodResolver(serverSchema)
})
```

**Server-Side Validation (Security):**
- All validation enforced on backend with class-validator
- Frontend validation is for UX only
- Never trust client-side validation alone
- Backend validates all inputs regardless of frontend

---

### 7.3 XSS Prevention

**Content Security Policy:**
```typescript
// next.config.ts
const securityHeaders = [
  {
    key: 'Content-Security-Policy',
    value: "default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline';"
  },
  {
    key: 'X-Content-Type-Options',
    value: 'nosniff'
  },
  {
    key: 'X-Frame-Options',
    value: 'DENY'
  },
  {
    key: 'X-XSS-Protection',
    value: '1; mode=block'
  }
]
```

**Output Encoding:**
- React automatically escapes JSX content
- Use `dangerouslySetInnerHTML` only when absolutely necessary
- Sanitize user-generated content before rendering
- Validate URLs before rendering links

---

### 7.4 CSRF Protection

**SameSite Cookies:**
```typescript
// Backend sets refresh token cookie with SameSite=Strict
res.cookie('refreshToken', token, {
  httpOnly: true,
  secure: true,
  sameSite: 'strict',
  maxAge: 7 * 24 * 60 * 60 * 1000 // 7 days
})
```

**CSRF Tokens (Future Enhancement):**
- Consider CSRF tokens for state-changing operations
- Double-submit cookie pattern
- Custom header verification

---

### 7.5 Sensitive Data Handling

**Never Display Credentials:**
```typescript
// âŒ WRONG: Displaying password field
<Input type="text" value={server.password} />

// âœ… CORRECT: Masked or hidden
<Input type="password" value="â€¢â€¢â€¢â€¢â€¢â€¢â€¢â€¢" disabled />
<Badge>Credentials Configured</Badge>
```

**Audit Logging:**
- Log all security-relevant actions
- Never log sensitive data (passwords, keys)
- Include user context (who, when, what, result)

---

## 8. Testing Strategy

### 8.1 Unit Testing

**Component Tests (React Testing Library):**
```typescript
// frontend/src/components/servers/ServerForm.test.tsx
import { render, screen, fireEvent, waitFor } from '@testing-library/react'
import { ServerForm } from './ServerForm'

describe('ServerForm', () => {
  it('should validate required fields', async () => {
    render(<ServerForm onSubmit={jest.fn()} />)
    
    const submitButton = screen.getByRole('button', { name: /save/i })
    fireEvent.click(submitButton)
    
    await waitFor(() => {
      expect(screen.getByText(/name is required/i)).toBeInTheDocument()
      expect(screen.getByText(/host is required/i)).toBeInTheDocument()
    })
  })

  it('should submit valid form data', async () => {
    const onSubmit = jest.fn()
    render(<ServerForm onSubmit={onSubmit} />)
    
    fireEvent.change(screen.getByLabelText(/name/i), {
      target: { value: 'Test Server' }
    })
    fireEvent.change(screen.getByLabelText(/host/i), {
      target: { value: '192.168.1.100' }
    })
    
    fireEvent.click(screen.getByRole('button', { name: /save/i }))
    
    await waitFor(() => {
      expect(onSubmit).toHaveBeenCalledWith(
        expect.objectContaining({
          name: 'Test Server',
          host: '192.168.1.100'
        })
      )
    })
  })
})
```

**Hook Tests:**
```typescript
// frontend/src/lib/api/hooks/useServers.test.ts
import { renderHook, waitFor } from '@testing-library/react'
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { useServers } from './useServers'

describe('useServers', () => {
  it('should fetch servers successfully', async () => {
    const queryClient = new QueryClient()
    const wrapper = ({ children }) => (
      <QueryClientProvider client={queryClient}>
        {children}
      </QueryClientProvider>
    )

    const { result } = renderHook(() => useServers(), { wrapper })

    await waitFor(() => {
      expect(result.current.isSuccess).toBe(true)
      expect(result.current.data).toBeDefined()
    })
  })
})
```

**Target Coverage:** >80% for critical components

---

### 8.2 Integration Testing

**API Integration Tests:**
```typescript
// frontend/src/lib/api/servers.test.ts
import { rest } from 'msw'
import { setupServer } from 'msw/node'
import { getServers, createServer } from './servers'

const server = setupServer(
  rest.get('/api/v1/servers', (req, res, ctx) => {
    return res(ctx.json({ servers: [], pagination: {} }))
  }),
  rest.post('/api/v1/servers', (req, res, ctx) => {
    return res(ctx.json({ id: '1', name: 'Test Server' }))
  })
)

beforeAll(() => server.listen())
afterEach(() => server.resetHandlers())
afterAll(() => server.close())

describe('Server API', () => {
  it('should fetch servers', async () => {
    const result = await getServers()
    expect(result.servers).toEqual([])
  })

  it('should create server', async () => {
    const result = await createServer({ name: 'Test Server', /* ... */ })
    expect(result.id).toBe('1')
  })
})
```

**Target Coverage:** >70% for API functions

---

### 8.3 End-to-End Testing

**User Flow Tests (Playwright):**
```typescript
// frontend/e2e/server-management.spec.ts
import { test, expect } from '@playwright/test'

test.describe('Server Management', () => {
  test.beforeEach(async ({ page }) => {
    // Login
    await page.goto('/login')
    await page.fill('[name="email"]', 'admin@system.local')
    await page.fill('[name="password"]', 'TestPassword123!')
    await page.click('button[type="submit"]')
    await expect(page).toHaveURL('/dashboard')
  })

  test('should create new server', async ({ page }) => {
    await page.goto('/servers')
    await page.click('text=Add Server')
    
    await page.fill('[name="name"]', 'Test Server')
    await page.fill('[name="host"]', '192.168.1.100')
    await page.fill('[name="port"]', '22')
    await page.fill('[name="username"]', 'root')
    
    await page.click('button:has-text("Save")')
    
    await expect(page.locator('text=Server created successfully')).toBeVisible()
    await expect(page.locator('text=Test Server')).toBeVisible()
  })

  test('should test server connection', async ({ page }) => {
    await page.goto('/servers')
    await page.click('text=Test Connection')
    
    await expect(page.locator('text=Testing connection...')).toBeVisible()
    await expect(page.locator('text=Connection successful')).toBeVisible()
  })
})
```

**Critical Paths to Test:**
- Login flow (email/password + MFA)
- Server CRUD operations
- Incident creation and state changes
- Playbook execution
- Settings configuration

**Target Coverage:** 100% of critical user journeys

---

### 8.4 Accessibility Testing

**Automated Testing:**
```typescript
// frontend/src/components/servers/ServerForm.test.tsx
import { axe, toHaveNoViolations } from 'jest-axe'

expect.extend(toHaveNoViolations)

it('should have no accessibility violations', async () => {
  const { container } = render(<ServerForm onSubmit={jest.fn()} />)
  const results = await axe(container)
  expect(results).toHaveNoViolations()
})
```

**Manual Testing:**
- Keyboard navigation (Tab, Enter, Escape)
- Screen reader compatibility (NVDA, JAWS)
- Color contrast verification
- Focus management
- ARIA labels and roles

**Target:** WCAG 2.1 AA compliance

---

## 9. Performance Requirements

### 9.1 Page Load Performance

**Targets:**
- Initial page load: <2s (3G connection)
- Time to Interactive (TTI): <3s
- First Contentful Paint (FCP): <1s
- Largest Contentful Paint (LCP): <2.5s

**Optimization Strategies:**
- Code splitting by route
- Lazy loading for non-critical components
- Image optimization with Next.js Image component
- Font optimization (preload, font-display: swap)
- Bundle size monitoring (<200KB initial bundle)

---

### 9.2 Runtime Performance

**Targets:**
- API response rendering: <100ms
- Real-time update latency: <500ms
- Table sorting/filtering: <50ms
- Form validation: <50ms

**Optimization Strategies:**
```typescript
// Virtualized lists for large datasets
import { useVirtualizer } from '@tanstack/react-virtual'

export function ServerList({ servers }: { servers: Server[] }) {
  const parentRef = useRef<HTMLDivElement>(null)
  
  const virtualizer = useVirtualizer({
    count: servers.length,
    getScrollElement: () => parentRef.current,
    estimateSize: () => 50
  })

  return (
    <div ref={parentRef} className="h-[600px] overflow-auto">
      <div style={{ height: `${virtualizer.getTotalSize()}px` }}>
        {virtualizer.getVirtualItems().map((virtualRow) => (
          <ServerRow key={virtualRow.key} server={servers[virtualRow.index]} />
        ))}
      </div>
    </div>
  )
}
```

```typescript
// Debounced search
import { useDebouncedValue } from '@/lib/hooks/useDebouncedValue'

export function ServerSearch() {
  const [search, setSearch] = useState('')
  const debouncedSearch = useDebouncedValue(search, 300)

  const { data } = useServers({ search: debouncedSearch })

  return <Input value={search} onChange={(e) => setSearch(e.target.value)} />
}
```

```typescript
// Memoized expensive computations
import { useMemo } from 'react'

export function IncidentStats({ incidents }: { incidents: Incident[] }) {
  const stats = useMemo(() => {
    return {
      critical: incidents.filter(i => i.severity === 'CRITICAL').length,
      high: incidents.filter(i => i.severity === 'HIGH').length,
      avgResolutionTime: calculateAvgResolutionTime(incidents)
    }
  }, [incidents])

  return <StatsDisplay stats={stats} />
}
```

---

### 9.3 Network Performance

**Targets:**
- API call response time: <200ms (p95)
- Concurrent requests: Support 50+ simultaneous
- Failed request retry: Max 3 attempts with exponential backoff

**Optimization Strategies:**
- Request deduplication (React Query)
- Optimistic updates for instant feedback
- Prefetching on hover/focus
- Request cancellation on unmount
- Compression (gzip/brotli)

---

## 10. Success Metrics

### 10.1 Functional Metrics

**Authentication:**
- [ ] Login success rate: >99%
- [ ] MFA setup completion: >80%
- [ ] Session timeout handling: 100%
- [ ] Token refresh success: >99%

**Resource Management:**
- [ ] Server CRUD operations: 100% functional
- [ ] Asset discovery success: >95%
- [ ] Connection test accuracy: >98%
- [ ] Bulk operations: Support 100+ items

**Incident Management:**
- [ ] Incident creation: <2s
- [ ] State transition validation: 100%
- [ ] Real-time updates: <5s latency
- [ ] Comment posting: <1s

**Automation:**
- [ ] Playbook execution trigger: <1s
- [ ] Log streaming: Real-time
- [ ] Execution history: Complete audit trail

---

### 10.2 Performance Metrics

**Page Load:**
- [ ] Dashboard load: <2s
- [ ] Server list load: <1.5s
- [ ] Incident board load: <2s
- [ ] Settings load: <1s

**Runtime:**
- [ ] Table sorting: <50ms
- [ ] Filter application: <100ms
- [ ] Search results: <200ms
- [ ] Form validation: <50ms

**Network:**
- [ ] API response time: <200ms (p95)
- [ ] Failed request rate: <0.1%
- [ ] Concurrent users: 1000+

---

### 10.3 Security Metrics

**Authentication:**
- [ ] Zero authentication bypasses
- [ ] Token expiration enforced: 100%
- [ ] RBAC violations: 0
- [ ] Credential leaks: 0

**Data Protection:**
- [ ] Sensitive data exposure: 0
- [ ] XSS vulnerabilities: 0
- [ ] CSRF vulnerabilities: 0
- [ ] Audit log coverage: 100%

---

### 10.4 Accessibility Metrics

**WCAG Compliance:**
- [ ] WCAG 2.1 AA: 100% compliance
- [ ] Keyboard navigation: All features accessible
- [ ] Screen reader compatibility: Full support
- [ ] Color contrast: AAA where possible

---

### 10.5 User Experience Metrics

**Usability:**
- [ ] Task completion rate: >95%
- [ ] Error rate: <5%
- [ ] User satisfaction: >4.5/5
- [ ] Training time: <2 hours for basic operations

**Responsiveness:**
- [ ] Mobile responsive: All pages
- [ ] Tablet optimized: All features
- [ ] Desktop optimized: Full functionality

---

## 11. Tech Stack Alignment Checklist

### âœ… Frontend Framework
- [x] Next.js 14 with App Router
- [x] React 18+
- [x] TypeScript (strict mode)
- [x] Server Components where applicable

### âœ… Styling & UI
- [x] Tailwind CSS for styling
- [x] shadcn/ui component library
- [x] Radix UI primitives
- [x] Lucide React icons
- [x] CSS Variables for theming

### âœ… State Management
- [x] Zustand for global state
- [x] React Query (TanStack Query) for server state
- [x] React Hook Form for form state
- [x] Zod for validation schemas

### âœ… API Integration
- [x] Axios for HTTP client
- [x] Interceptors for auth and error handling
- [x] Type-safe API functions
- [x] Shared types with backend

### âœ… Authentication
- [x] JWT tokens (access in memory, refresh in cookie)
- [x] Automatic token refresh
- [x] RBAC enforcement in UI
- [x] Route protection middleware

### âœ… Security
- [x] Input validation (client + server)
- [x] XSS prevention
- [x] CSRF protection (SameSite cookies)
- [x] Content Security Policy
- [x] No credential exposure

### âœ… Testing
- [x] Jest for unit tests
- [x] React Testing Library for component tests
- [x] MSW for API mocking
- [x] Playwright for E2E tests
- [x] jest-axe for accessibility tests

### âœ… Performance
- [x] Code splitting
- [x] Lazy loading
- [x] Image optimization
- [x] Bundle size monitoring
- [x] React Query caching

### âœ… Development Tools
- [x] ESLint for linting
- [x] Prettier for formatting
- [x] TypeScript strict mode
- [x] Git hooks (Husky)

---

## 12. Documentation Deliverables

### 12.1 Technical Documentation

**Architecture Documentation:**
- Component hierarchy diagram
- State management flow
- API integration patterns
- Authentication flow diagram
- Real-time update architecture

**API Documentation:**
- API client usage guide
- Type definitions reference
- Error handling patterns
- Authentication integration

**Development Guide:**
- Project setup instructions
- Development workflow
- Testing guidelines
- Deployment procedures

---

### 12.2 User Documentation

**User Guide:**
- Login and authentication
- Dashboard overview
- Server management
- Asset registry
- Incident response
- Automation execution
- Settings configuration

**Administrator Guide:**
- User management
- Role configuration
- Integration setup
- Notification rules
- Audit log review

---

### 12.3 Component Documentation

**Storybook:**
- All UI components documented
- Interactive examples
- Props documentation
- Accessibility notes
- Usage guidelines

---

## 13. Implementation Guidelines

### Phase 1: Foundation & Authentication (Week 1-2)

**Day 1-2: Project Setup**
```bash
# Initialize Next.js project
npx create-next-app@latest frontend --typescript --tailwind --app

# Install dependencies
cd frontend
npm install @tanstack/react-query zustand axios
npm install @radix-ui/react-* class-variance-authority clsx tailwind-merge
npm install react-hook-form @hookform/resolvers zod
npm install lucide-react
npm install -D @types/node @types/react @types/react-dom

# Initialize shadcn/ui
npx shadcn-ui@latest init
```

**Day 3-5: Authentication UI**
- Implement login page with email/password form
- Add MFA verification flow
- Create token manager
- Setup API client with interceptors
- Implement auth guard middleware

**Day 6-10: Application Shell**
- Build sidebar navigation
- Create header with breadcrumbs
- Implement global status bar
- Setup toast notification system
- Create layout components

**Acceptance Criteria:**
- User can log in successfully
- MFA challenge appears when required
- Protected routes redirect to login
- Sidebar navigation functional
- Toast notifications display

---

### Phase 2: Dashboard & Core Resources (Week 3-4)

**Day 11-15: Dashboard**
- Implement system health widget
- Create incident feed widget
- Build server utilization charts
- Add recent automations feed
- Setup real-time polling

**Day 16-20: Server Management**
- Build server list page with table
- Implement server filters and search
- Create server detail page
- Add connection test functionality
- Build terminal modal

**Acceptance Criteria:**
- Dashboard loads in <2s
- Server list fetches from API
- Filters and pagination work
- Connection test displays results

---

### Phase 3: Incident & Automation (Week 5-6)

**Day 21-25: Incident Management**
- Build incident list page
- Implement Kanban board with drag-and-drop
- Create incident detail page
- Add timeline and comment system
- Setup real-time incident updates

**Day 26-30: Automation Hub**
- Build playbook library
- Implement playbook execution form
- Create execution history page
- Build log viewer modal
- Add real-time execution updates

**Acceptance Criteria:**
- Kanban board allows state changes
- Incidents update in real-time
- Playbooks can be executed
- Logs display correctly

---

### Phase 4: Settings & Polish (Week 7-8)

**Day 31-35: Settings Pages**
- Build user management page
- Implement integration configuration
- Create notification rules builder
- Build audit log viewer
- Add global search

**Day 36-40: Optimization & Testing**
- Performance optimization
- Accessibility audit
- Mobile responsive testing
- E2E test implementation
- Documentation completion

**Acceptance Criteria:**
- All settings pages functional
- WCAG AA compliance verified
- Mobile responsive on all pages
- E2E tests passing

---

## 14. Deployment Strategy

### Development Environment
```bash
# Start development server
npm run dev

# Run tests
npm run test
npm run test:e2e

# Build for production
npm run build

# Start production server
npm start
```

### Production Deployment
```dockerfile
# Dockerfile
FROM node:20-alpine AS builder
WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .
RUN npm run build

FROM node:20-alpine AS runner
WORKDIR /app
ENV NODE_ENV=production
COPY --from=builder /app/next.config.ts ./
COPY --from=builder /app/public ./public
COPY --from=builder /app/.next/standalone ./
COPY --from=builder /app/.next/static ./.next/static

EXPOSE 3000
CMD ["node", "server.js"]
```

### Environment Variables
```bash
# .env.production
NEXT_PUBLIC_API_URL=https://api.opsmanager.com/api/v1
NEXT_PUBLIC_WS_URL=wss://api.opsmanager.com
```

---

## 15. Conclusion

The Admin Control Panel (Module 9) is the **user-facing interface** that brings together all backend modules into a unified, intuitive operations dashboard. By following this implementation plan with strict adherence to the tech stack (Next.js 14, Tailwind CSS, React Query, Zustand, shadcn/ui), the frontend will provide:

- **Unified Operations:** Single interface for all infrastructure management
- **Real-Time Visibility:** Live updates on system health and incidents
- **Intuitive UX:** Dense, information-rich interface optimized for engineers
- **Enterprise Security:** RBAC enforcement, secure authentication, audit logging
- **High Performance:** <2s page loads, <500ms real-time updates
- **Accessibility:** WCAG AA compliant for inclusive operations

**Next Steps:**
1. Review and approve this implementation plan
2. Setup Next.js project with required dependencies
3. Begin Sprint 1: Foundation & Authentication
4. Iterate through sprints with continuous testing and feedback

---

**Document Control:**
- **Version:** 2.0.0
- **Created:** February 8, 2026
- **Status:** Implementation Ready
- **Owner:** Frontend Engineering Team
- **Classification:** Technical Implementation Plan
