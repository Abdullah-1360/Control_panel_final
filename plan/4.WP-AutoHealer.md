# Module 4: WordPress Auto-Healer & Application Reliability Engine

## Professional Implementation Plan

**Module ID:** `MOD-04-WP-HEALER`  
**Version:** 2.0.0  
**Status:** Ready for Implementation  
**Priority:** P1 (Application Reliability)  
**Dependencies:** Module 1 (Auth), Module 2 (Server Connections), Module 3 (Integration Hub), Module 5 (Automation), Module 6 (Incident Management), Module 7 (Logging)  
**Estimated Duration:** 5-6 weeks (200-240 hours)  
**Team Size:** 2-3 Backend Engineers, 1 Frontend Engineer

---

## ðŸŽ¯ IMPLEMENTATION DECISIONS (Feb 13, 2026)

**Core Engine:** NestJS service with TypeScript-based healing runbooks  
**Detection Strategy:** Reactive (Log parsing + HTTP checks) + Proactive (Health monitoring)  
**Execution Method:** SSH via Module 2 + wp-cli wrapper  
**Safety Protocol:** "Do No Harm" - Max 1 healing attempt per 30 mins per site  
**State Management:** State Machine (HEALTHY â†’ DEGRADED â†’ HEALING â†’ RECOVERED â†’ FAILED)  
**Logs:** Dedicated `HealerExecution` table + Module 7 integration  
**Rollback:** Automatic backup before mutations + rollback capability  
**Queue:** BullMQ for async healing jobs  
**Cache:** Redis for healing locks and rate limiting  
**SRE Focus:** Self-healing, automated remediation, MTTR reduction

---

## 1. Executive Summary

### 1.1 Business Value

The **WordPress Auto-Healer** transforms OpsManager from a passive monitoring tool into an active **Application Reliability Platform**. By autonomously resolving the 5 most common WordPress outagesâ€”White Screen of Death (WSOD), Database Connection Errors, Stuck Maintenance Mode, Core File Corruption, and Plugin Conflictsâ€”this module directly reduces support ticket volume by an estimated 40-50% and MTTR by 60%.

**Key Business Outcomes:**

* **Zero-Touch Resolution:** Automatically fix "Stuck Maintenance Mode" and "WSOD" in <30 seconds
* **Customer Trust:** Sites recover before customers notice downtime
* **Operational Efficiency:** Eliminates repetitive toil of manual SSH debugging
* **Security Posture:** Automatically detects and reverts core file tampering
* **Cost Reduction:** Reduces support ticket volume by 40-50%
* **SRE Excellence:** Automated runbooks, error budget tracking, blameless postmortems

### 1.2 Technical Highlights

* **Surgical Remediation:** Uses `wp-cli` to target specific plugins/themes
* **Log Forensics:** Parses PHP error logs to identify exact failure points
* **Smart Retries:** Exponential backoff prevents healing loops
* **Context-Aware:** Distinguishes between database issues and credential problems
* **Integration-First:** Leverages Module 2 (SSH), Module 3 (WHM), Module 5 (Automation)
* **Observable:** Full integration with Module 7 for distributed tracing
* **Safe:** Automatic backups, rollback capability, circuit breakers

---

## 2. Technical Architecture

### 2.1 System Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Trigger Sources                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ Incident â”‚  â”‚  Manual  â”‚  â”‚ Scheduledâ”‚  â”‚  Webhook â”‚   â”‚
â”‚  â”‚  Module  â”‚  â”‚ Trigger  â”‚  â”‚  Health  â”‚  â”‚  Event   â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
                            â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  Healer Orchestrator                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  1. Validate (Rate Limit, Lock Check)                â”‚  â”‚
â”‚  â”‚  2. Diagnose (Log Parser, Health Checker)            â”‚  â”‚
â”‚  â”‚  3. Prescribe (Runbook Selector)                     â”‚  â”‚
â”‚  â”‚  4. Execute (Healing Runbook via BullMQ)             â”‚  â”‚
â”‚  â”‚  5. Verify (Health Check, Rollback if needed)        â”‚  â”‚
â”‚  â”‚  6. Notify (Incident Update, Notifications)          â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
                            â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  Healing Runbooks                            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚
â”‚  â”‚   WSOD     â”‚  â”‚  Database  â”‚  â”‚Maintenance â”‚           â”‚
â”‚  â”‚  Healer    â”‚  â”‚   Healer   â”‚  â”‚   Healer   â”‚           â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚
â”‚  â”‚ Integrity  â”‚  â”‚Permission  â”‚  â”‚   Cache    â”‚           â”‚
â”‚  â”‚  Healer    â”‚  â”‚   Healer   â”‚  â”‚   Healer   â”‚           â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
                            â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  Execution Layer                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚  Module 2    â”‚  â”‚  Module 3    â”‚  â”‚   wp-cli     â”‚     â”‚
â”‚  â”‚    (SSH)     â”‚  â”‚    (WHM)     â”‚  â”‚   Wrapper    â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
                            â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  WordPress Sites                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```


### 2.2 The "Healer Loop" Logic

```typescript
// Healer Orchestrator Flow
async healSite(siteId: string, trigger: HealerTrigger): Promise<HealerResult> {
  // 1. VALIDATE
  const lock = await this.acquireLock(siteId);
  if (!lock) {
    return { status: 'SKIPPED', reason: 'Already healing or rate limited' };
  }
  
  try {
    // 2. DIAGNOSE
    const diagnosis = await this.diagnosisService.diagnose(siteId);
    
    // 3. PRESCRIBE
    const runbook = await this.runbookSelector.select(diagnosis);
    
    // 4. EXECUTE (via BullMQ)
    const execution = await this.healerQueue.add('heal', {
      siteId,
      runbookId: runbook.id,
      diagnosis,
      trigger
    });
    
    // 5. VERIFY (after execution completes)
    const result = await execution.finished();
    
    // 6. NOTIFY
    await this.notificationService.notifyHealing(siteId, result);
    
    return result;
  } finally {
    await this.releaseLock(siteId);
  }
}
```

**Key Principles:**
1. **Idempotency:** Same diagnosis always produces same healing action
2. **Atomicity:** Each healing attempt is a single transaction
3. **Observability:** Every step logged to Module 7
4. **Safety:** Automatic rollback on failure
5. **Rate Limiting:** Max 1 healing per 30 mins per site

---

## 3. Implementation Roadmap

### Sprint 1: Core Infrastructure & Site Management (Week 1)

**Goal:** Database schema, site discovery, and basic CRUD operations

#### Backend Tasks

1. **Database Schema & Migrations**
   - [ ] Design `WpSite` model with health tracking
   - [ ] Design `HealerExecution` model with detailed logging
   - [ ] Design `HealerRule` model for custom healing rules
   - [ ] Design `HealerBackup` model for rollback capability
   - [ ] Create Prisma migrations
   - [ ] Add indexes for performance
   - [ ] Create seed data for testing

2. **Site Discovery Service**
   - [ ] Implement WHM integration for site discovery
   - [ ] Create site scanning logic (find WordPress installations)
   - [ ] Build wp-cli detection and version checking
   - [ ] Implement site metadata extraction (PHP version, WP version)
   - [ ] Create site registration workflow
   - [ ] Build site health status tracking

3. **WP-CLI Wrapper Service**
   - [ ] Create WpCliService with SSH integration (Module 2)
   - [ ] Implement command execution with timeout
   - [ ] Build output parsing and error handling
   - [ ] Create command validation and sanitization
   - [ ] Implement sudo/privilege escalation handling
   - [ ] Add command logging to Module 7

4. **Health Monitoring Service**
   - [ ] Implement HTTP health checks (status code, response time)
   - [ ] Create database connectivity checks
   - [ ] Build file system checks (permissions, disk space)
   - [ ] Implement PHP error log monitoring
   - [ ] Create health score calculation
   - [ ] Build health status state machine

#### Testing & Documentation
- [ ] Unit tests for site discovery
- [ ] Unit tests for wp-cli wrapper
- [ ] Integration tests with mock SSH
- [ ] Database migration testing
- [ ] API documentation setup

**Deliverables:**
- âœ… Working database schema
- âœ… Site discovery operational
- âœ… WP-CLI wrapper functional
- âœ… Health monitoring active
- âœ… Basic CRUD operations

---

### Sprint 2: Diagnosis Engine & Log Parser (Week 2)

**Goal:** Intelligent diagnosis of WordPress issues

#### Backend Tasks

1. **Log Parser Service**
   - [ ] Create regex patterns for common PHP errors
   - [ ] Implement plugin fault detection
   - [ ] Build theme fault detection
   - [ ] Create database error pattern matching
   - [ ] Implement memory limit detection
   - [ ] Build syntax error detection
   - [ ] Create confidence scoring algorithm

2. **Diagnosis Engine**
   - [ ] Implement multi-source diagnosis (logs + HTTP + DB)
   - [ ] Create diagnosis result aggregation
   - [ ] Build root cause analysis logic
   - [ ] Implement diagnosis caching (Redis)
   - [ ] Create diagnosis history tracking
   - [ ] Build diagnosis confidence scoring

3. **Error Pattern Library**
   - [ ] Define WSOD patterns (fatal errors, memory exhaustion)
   - [ ] Define database error patterns (connection refused, access denied)
   - [ ] Define maintenance mode patterns (stuck .maintenance file)
   - [ ] Define core integrity patterns (modified core files)
   - [ ] Define permission error patterns (403, file write failures)
   - [ ] Define plugin conflict patterns (fatal errors in plugins)

4. **Health Check Service**
   - [ ] Implement HTTP status code checking
   - [ ] Create response time monitoring
   - [ ] Build database connectivity testing
   - [ ] Implement file system health checks
   - [ ] Create PHP version compatibility checks
   - [ ] Build SSL certificate validation

#### Testing & Documentation
- [ ] Unit tests for log parser
- [ ] Unit tests for diagnosis engine
- [ ] Pattern matching accuracy testing
- [ ] Diagnosis confidence validation
- [ ] Complete diagnosis documentation

**Deliverables:**
- âœ… Log parser operational
- âœ… Diagnosis engine functional
- âœ… Error pattern library complete
- âœ… Health check service active
- âœ… >90% diagnosis accuracy

---

### Sprint 3: Healing Runbooks (Week 3-4)

**Goal:** Implement core healing runbooks

#### Backend Tasks

1. **Runbook Framework**
   - [ ] Create `HealingRunbook` interface
   - [ ] Implement base runbook class with common logic
   - [ ] Build runbook registry and selector
   - [ ] Create runbook execution context
   - [ ] Implement runbook lifecycle hooks
   - [ ] Build runbook error handling

2. **WSOD Healer Runbook**
   - [ ] Implement WP_DEBUG enablement
   - [ ] Create error log reading and parsing
   - [ ] Build plugin deactivation logic
   - [ ] Implement theme switching to default
   - [ ] Create "safe mode" (deactivate all plugins)
   - [ ] Build verification logic

3. **Maintenance Mode Healer Runbook**
   - [ ] Detect stuck .maintenance file
   - [ ] Implement file age checking
   - [ ] Create .maintenance file removal
   - [ ] Build verification logic
   - [ ] Implement backup before removal

4. **Database Healer Runbook**
   - [ ] Check MySQL service status
   - [ ] Validate wp-config.php credentials
   - [ ] Implement `wp db check` execution
   - [ ] Create `wp db repair` logic
   - [ ] Build database optimization
   - [ ] Implement connection pool reset

5. **Core Integrity Healer Runbook**
   - [ ] Implement `wp core verify-checksums`
   - [ ] Create modified file detection
   - [ ] Build `wp core download --force` logic
   - [ ] Implement selective file restoration
   - [ ] Create backup before restoration
   - [ ] Build verification logic

6. **Permission Healer Runbook**
   - [ ] Detect permission errors (403, file write failures)
   - [ ] Implement safe permission reset (644 files, 755 dirs)
   - [ ] Create ownership correction (www-data, apache, nginx)
   - [ ] Build wp-content permission fixing
   - [ ] Implement verification logic

7. **Cache Healer Runbook**
   - [ ] Implement object cache flush
   - [ ] Create transient cleanup
   - [ ] Build page cache clearing
   - [ ] Implement CDN cache purge (if integrated)
   - [ ] Create verification logic

#### Testing & Documentation
- [ ] Unit tests for each runbook
- [ ] Integration tests with mock sites
- [ ] Runbook execution validation
- [ ] Safety testing (no destructive actions)
- [ ] Complete runbook documentation

**Deliverables:**
- âœ… Runbook framework operational
- âœ… 6 core runbooks implemented
- âœ… Runbook selector functional
- âœ… >95% healing success rate
- âœ… Zero destructive operations

---


### Sprint 4: Orchestration & Safety (Week 5)

**Goal:** Healer orchestrator, safety rails, and backup/rollback

#### Backend Tasks

1. **Healer Orchestrator Service**
   - [ ] Implement healing workflow orchestration
   - [ ] Create lock acquisition/release (Redis)
   - [ ] Build rate limiting (max 1 per 30 mins)
   - [ ] Implement healing queue (BullMQ)
   - [ ] Create execution tracking
   - [ ] Build result aggregation

2. **Safety Rails**
   - [ ] Implement circuit breaker pattern
   - [ ] Create healing attempt limits (max 3 per day)
   - [ ] Build escalation logic (to human after max attempts)
   - [ ] Implement dry-run mode (test without execution)
   - [ ] Create blacklist (never touch certain plugins)
   - [ ] Build whitelist (only heal approved sites)

3. **Backup & Rollback Service**
   - [ ] Implement pre-healing backup
   - [ ] Create file backup (.htaccess, wp-config.php, plugins)
   - [ ] Build database backup (wp db export)
   - [ ] Implement rollback logic
   - [ ] Create backup retention policy (7 days)
   - [ ] Build backup verification

4. **Healing Queue (BullMQ)**
   - [ ] Create healing job processor
   - [ ] Implement job retry logic (exponential backoff)
   - [ ] Build job timeout handling
   - [ ] Create job priority system
   - [ ] Implement job progress tracking
   - [ ] Build job failure handling

5. **Integration with Module 6 (Incidents)**
   - [ ] Create incident-triggered healing
   - [ ] Implement healing result â†’ incident update
   - [ ] Build automatic incident resolution
   - [ ] Create escalation on healing failure
   - [ ] Implement healing timeline in incident

6. **Integration with Module 7 (Logging)**
   - [ ] Implement structured logging for all healing steps
   - [ ] Create distributed tracing for healing workflows
   - [ ] Build healing metrics (success rate, MTTR)
   - [ ] Implement log sanitization (no credentials)
   - [ ] Create healing audit trail

#### Testing & Documentation
- [ ] Unit tests for orchestrator
- [ ] Integration tests for safety rails
- [ ] Backup/rollback testing
- [ ] Queue processing testing
- [ ] Complete orchestration documentation

**Deliverables:**
- âœ… Orchestrator operational
- âœ… Safety rails enforced
- âœ… Backup/rollback functional
- âœ… BullMQ queue operational
- âœ… Module 6 & 7 integration complete

---

### Sprint 5: API & Frontend (Week 6)

**Goal:** REST API and admin UI for healer management

#### Backend Tasks

1. **REST API Endpoints**
   - [ ] POST /api/v1/healer/sites - Register site
   - [ ] GET /api/v1/healer/sites - List sites
   - [ ] GET /api/v1/healer/sites/:id - Get site details
   - [ ] PATCH /api/v1/healer/sites/:id - Update site config
   - [ ] DELETE /api/v1/healer/sites/:id - Remove site
   - [ ] POST /api/v1/healer/sites/:id/diagnose - Manual diagnosis
   - [ ] POST /api/v1/healer/sites/:id/heal - Manual healing
   - [ ] GET /api/v1/healer/sites/:id/executions - Healing history
   - [ ] POST /api/v1/healer/sites/:id/rollback/:executionId - Rollback
   - [ ] GET /api/v1/healer/stats - Healer statistics

2. **RBAC Integration**
   - [ ] Implement permission guards
   - [ ] Create role-based filtering
   - [ ] Build audit logging
   - [ ] Add rate limiting per user

3. **Swagger Documentation**
   - [ ] Document all endpoints
   - [ ] Create request/response examples
   - [ ] Build error code documentation
   - [ ] Implement API versioning

#### Frontend Tasks

1. **Site Management UI**
   - [ ] Create site list page with health status
   - [ ] Build site registration form
   - [ ] Implement site detail page
   - [ ] Create site configuration panel
   - [ ] Build site health dashboard

2. **Healing Control Panel**
   - [ ] Create "Diagnose" button with real-time feedback
   - [ ] Build "Heal Now" button with confirmation
   - [ ] Implement healing progress indicator
   - [ ] Create healing history timeline
   - [ ] Build rollback UI

3. **Healing History & Analytics**
   - [ ] Create healing execution list
   - [ ] Build execution detail view with logs
   - [ ] Implement healing success rate chart
   - [ ] Create MTTR reduction metrics
   - [ ] Build healing frequency chart

4. **Safety Configuration UI**
   - [ ] Create auto-healing toggle per site
   - [ ] Build healing attempt limit configuration
   - [ ] Implement plugin blacklist management
   - [ ] Create dry-run mode toggle
   - [ ] Build escalation policy configuration

#### Testing & Documentation
- [ ] API endpoint testing
- [ ] Frontend component testing
- [ ] E2E testing for critical flows
- [ ] Complete user documentation
- [ ] Create troubleshooting guide

**Deliverables:**
- âœ… Complete REST API
- âœ… Swagger documentation
- âœ… Site management UI
- âœ… Healing control panel
- âœ… Analytics dashboard
- âœ… User documentation

---

## 4. Database Schema (Prisma)

```prisma
// WordPress Site Model
model WpSite {
  id              String   @id @default(uuid())
  
  // Server & Integration
  serverId        String
  server          Server   @relation(fields: [serverId], references: [id], onDelete: Cascade)
  integrationId   String?  // WHM integration (optional)
  integration     Integration? @relation(fields: [integrationId], references: [id])
  
  // Site Identity
  domain          String   @unique
  path            String   // /var/www/html/site or /home/user/public_html
  cPanelUsername  String?  // For WHM-managed sites
  
  // WordPress Info
  wpVersion       String?
  phpVersion      String?
  dbName          String?
  dbHost          String?  @default("localhost")
  
  // Healer Configuration
  isHealerEnabled Boolean  @default(false)
  autoUpdateCore  Boolean  @default(false)
  autoUpdatePlugin Boolean @default(false)
  maxHealingAttempts Int   @default(3)
  healingCooldown Int      @default(1800) // 30 minutes in seconds
  
  // Plugin/Theme Blacklist
  blacklistedPlugins String[] // Never deactivate these
  blacklistedThemes  String[] // Never switch from these
  
  // Health Status
  healthStatus    HealthStatus @default(UNKNOWN)
  lastHealthCheck DateTime?
  healthScore     Int?         // 0-100
  lastError       String?      @db.Text
  
  // Operational
  lastHealedAt    DateTime?
  healingAttempts Int          @default(0)
  
  // Relations
  executions      HealerExecution[]
  backups         HealerBackup[]
  rules           HealerRule[]
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  @@index([serverId])
  @@index([integrationId])
  @@index([healthStatus])
  @@index([isHealerEnabled])
  @@map("wp_sites")
}

// Healer Execution Model
model HealerExecution {
  id              String   @id @default(uuid())
  
  // Site & Incident
  siteId          String
  site            WpSite   @relation(fields: [siteId], references: [id], onDelete: Cascade)
  incidentId      String?  // Linked to Module 6
  incident        Incident? @relation(fields: [incidentId], references: [id])
  
  // Trigger
  trigger         HealerTrigger // INCIDENT, MANUAL, SCHEDULED, WEBHOOK
  triggeredBy     String?       // User ID if manual
  
  // Diagnosis
  diagnosisType   DiagnosisType // WSOD, DB_ERROR, MAINTENANCE, INTEGRITY, PERMISSION
  diagnosisDetails String       @db.Text // JSON with detailed diagnosis
  confidence      Float         // 0.0-1.0
  
  // Healing
  runbookId       String
  runbook         HealerRunbook @relation(fields: [runbookId], references: [id])
  actionTaken     String        @db.Text // Detailed description
  
  // Backup
  backupId        String?
  backup          HealerBackup? @relation(fields: [backupId], references: [id])
  
  // Status
  status          HealerStatus  // PENDING, ANALYZING, HEALING, SUCCESS, FAILED, ROLLED_BACK
  errorMessage    String?       @db.Text
  
  // Logs
  logs            String        @db.Text // Structured JSON logs
  
  // Timing
  startedAt       DateTime      @default(now())
  diagnosedAt     DateTime?
  healedAt        DateTime?
  verifiedAt      DateTime?
  finishedAt      DateTime?
  duration        Int?          // milliseconds
  
  // Verification
  preHealthScore  Int?
  postHealthScore Int?
  wasSuccessful   Boolean       @default(false)
  
  @@index([siteId])
  @@index([incidentId])
  @@index([status])
  @@index([trigger])
  @@index([diagnosisType])
  @@index([startedAt])
  @@map("healer_executions")
}

// Healer Runbook Model
model HealerRunbook {
  id              String   @id @default(uuid())
  
  // Identity
  name            String   @unique
  description     String   @db.Text
  category        RunbookCategory // WSOD, DATABASE, MAINTENANCE, INTEGRITY, PERMISSION, CACHE
  
  // Configuration
  isActive        Boolean  @default(true)
  priority        Int      @default(50) // 0-100, higher = higher priority
  
  // Safety
  requiresBackup  Boolean  @default(true)
  isDryRunnable   Boolean  @default(true)
  maxRetries      Int      @default(3)
  timeout         Int      @default(300) // seconds
  
  // Implementation
  handlerClass    String   // TypeScript class name
  
  // Relations
  executions      HealerExecution[]
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  @@index([category])
  @@index([isActive])
  @@map("healer_runbooks")
}

// Healer Backup Model
model HealerBackup {
  id              String   @id @default(uuid())
  
  // Site
  siteId          String
  site            WpSite   @relation(fields: [siteId], references: [id], onDelete: Cascade)
  
  // Backup Details
  backupType      BackupType // FILE, DATABASE, FULL
  filePath        String?    // Path to backup file
  fileSize        Int?       // bytes
  
  // Metadata
  backupData      String     @db.Text // JSON with backup metadata
  
  // Status
  status          BackupStatus // PENDING, COMPLETED, FAILED, EXPIRED
  
  // Relations
  executions      HealerExecution[]
  
  // Timing
  createdAt       DateTime @default(now())
  expiresAt       DateTime // Auto-delete after 7 days
  
  @@index([siteId])
  @@index([status])
  @@index([expiresAt])
  @@map("healer_backups")
}

// Healer Rule Model (Custom Healing Rules)
model HealerRule {
  id              String   @id @default(uuid())
  
  // Site
  siteId          String
  site            WpSite   @relation(fields: [siteId], references: [id], onDelete: Cascade)
  
  // Rule Definition
  name            String
  description     String   @db.Text
  
  // Condition
  condition       String   @db.Text // JSON with condition logic
  
  // Action
  runbookId       String
  runbook         HealerRunbook @relation(fields: [runbookId], references: [id])
  
  // Configuration
  isActive        Boolean  @default(true)
  priority        Int      @default(50)
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  @@index([siteId])
  @@index([isActive])
  @@map("healer_rules")
}

// Enums
enum HealthStatus {
  UNKNOWN
  HEALTHY
  DEGRADED
  DOWN
  MAINTENANCE
  HEALING
}

enum HealerTrigger {
  INCIDENT
  MANUAL
  SCHEDULED
  WEBHOOK
}

enum DiagnosisType {
  WSOD
  DB_ERROR
  MAINTENANCE
  INTEGRITY
  PERMISSION
  CACHE
  PLUGIN_CONFLICT
  THEME_CONFLICT
  MEMORY_EXHAUSTION
  UNKNOWN
}

enum HealerStatus {
  PENDING
  ANALYZING
  HEALING
  VERIFYING
  SUCCESS
  FAILED
  SKIPPED
  ROLLED_BACK
}

enum RunbookCategory {
  WSOD
  DATABASE
  MAINTENANCE
  INTEGRITY
  PERMISSION
  CACHE
  PLUGIN
  THEME
  CUSTOM
}

enum BackupType {
  FILE
  DATABASE
  FULL
}

enum BackupStatus {
  PENDING
  COMPLETED
  FAILED
  EXPIRED
}
```

---


## 5. API Specification

### 5.1 Site Management

#### POST /api/v1/healer/sites
Register a new WordPress site for healing

**Request Body:**
```json
{
  "serverId": "srv_abc123",
  "integrationId": "int_whm_xyz",
  "domain": "example.com",
  "path": "/home/user/public_html",
  "cPanelUsername": "user",
  "isHealerEnabled": true,
  "maxHealingAttempts": 3,
  "healingCooldown": 1800,
  "blacklistedPlugins": ["woocommerce", "elementor"],
  "blacklistedThemes": ["divi"]
}
```

**Response:** 201 Created
```json
{
  "id": "site_abc123",
  "domain": "example.com",
  "healthStatus": "UNKNOWN",
  "isHealerEnabled": true,
  "createdAt": "2026-02-13T10:00:00Z"
}
```

#### GET /api/v1/healer/sites
List all WordPress sites

**Query Parameters:**
- `page` (number): Page number (default: 1)
- `limit` (number): Items per page (default: 50)
- `healthStatus` (enum): Filter by health status
- `isHealerEnabled` (boolean): Filter by healer status
- `search` (string): Search by domain

**Response:** 200 OK
```json
{
  "data": [
    {
      "id": "site_abc123",
      "domain": "example.com",
      "healthStatus": "HEALTHY",
      "healthScore": 95,
      "isHealerEnabled": true,
      "lastHealthCheck": "2026-02-13T10:00:00Z",
      "lastHealedAt": "2026-02-12T14:30:00Z",
      "healingAttempts": 2
    }
  ],
  "pagination": {
    "total": 100,
    "page": 1,
    "limit": 50,
    "totalPages": 2
  }
}
```

#### GET /api/v1/healer/sites/:id
Get site details

**Response:** 200 OK
```json
{
  "id": "site_abc123",
  "domain": "example.com",
  "path": "/home/user/public_html",
  "server": {
    "id": "srv_abc123",
    "hostname": "server1.host.com"
  },
  "wpVersion": "6.4.2",
  "phpVersion": "8.2",
  "healthStatus": "HEALTHY",
  "healthScore": 95,
  "isHealerEnabled": true,
  "maxHealingAttempts": 3,
  "healingCooldown": 1800,
  "blacklistedPlugins": ["woocommerce"],
  "lastHealthCheck": "2026-02-13T10:00:00Z",
  "lastHealedAt": "2026-02-12T14:30:00Z",
  "healingAttempts": 2,
  "stats": {
    "totalHealings": 12,
    "successRate": 0.92,
    "avgHealingTime": 45000,
    "uptimeSaved": "4h 20m"
  }
}
```

#### PATCH /api/v1/healer/sites/:id
Update site configuration

**Request Body:**
```json
{
  "isHealerEnabled": false,
  "maxHealingAttempts": 5,
  "blacklistedPlugins": ["woocommerce", "elementor", "yoast-seo"]
}
```

**Response:** 200 OK

#### DELETE /api/v1/healer/sites/:id
Remove site from healer

**Response:** 204 No Content

---

### 5.2 Healing Operations

#### POST /api/v1/healer/sites/:id/diagnose
Manually trigger diagnosis

**Request Body:**
```json
{
  "force": false // Skip cache, force fresh diagnosis
}
```

**Response:** 200 OK
```json
{
  "diagnosisType": "WSOD",
  "confidence": 0.95,
  "details": {
    "errorType": "PLUGIN_FAULT",
    "culprit": "elementor",
    "errorMessage": "PHP Fatal error: Uncaught Error: Call to undefined function...",
    "logFile": "/home/user/public_html/wp-content/debug.log",
    "timestamp": "2026-02-13T10:00:00Z"
  },
  "recommendedRunbook": {
    "id": "runbook_wsod",
    "name": "WSOD Healer",
    "description": "Deactivate faulty plugin causing white screen"
  },
  "diagnosedAt": "2026-02-13T10:00:05Z"
}
```

#### POST /api/v1/healer/sites/:id/heal
Manually trigger healing

**Request Body:**
```json
{
  "runbookId": "runbook_wsod", // Optional, auto-select if omitted
  "dryRun": false,
  "force": false // Skip rate limit check
}
```

**Response:** 202 Accepted
```json
{
  "executionId": "exec_abc123",
  "status": "PENDING",
  "message": "Healing job queued",
  "estimatedDuration": 60000 // milliseconds
}
```

#### GET /api/v1/healer/sites/:id/executions
Get healing history

**Query Parameters:**
- `page` (number): Page number
- `limit` (number): Items per page
- `status` (enum): Filter by status
- `trigger` (enum): Filter by trigger type

**Response:** 200 OK
```json
{
  "data": [
    {
      "id": "exec_abc123",
      "trigger": "INCIDENT",
      "diagnosisType": "WSOD",
      "runbook": {
        "id": "runbook_wsod",
        "name": "WSOD Healer"
      },
      "status": "SUCCESS",
      "actionTaken": "Deactivated plugin: elementor",
      "preHealthScore": 20,
      "postHealthScore": 95,
      "duration": 45000,
      "startedAt": "2026-02-13T10:00:00Z",
      "finishedAt": "2026-02-13T10:00:45Z"
    }
  ],
  "pagination": {
    "total": 50,
    "page": 1,
    "limit": 20,
    "totalPages": 3
  }
}
```

#### GET /api/v1/healer/executions/:id
Get execution details

**Response:** 200 OK
```json
{
  "id": "exec_abc123",
  "site": {
    "id": "site_abc123",
    "domain": "example.com"
  },
  "incident": {
    "id": "inc_xyz789",
    "title": "Site Down - HTTP 500"
  },
  "trigger": "INCIDENT",
  "triggeredBy": null,
  "diagnosisType": "WSOD",
  "diagnosisDetails": {
    "errorType": "PLUGIN_FAULT",
    "culprit": "elementor",
    "errorMessage": "PHP Fatal error...",
    "confidence": 0.95
  },
  "runbook": {
    "id": "runbook_wsod",
    "name": "WSOD Healer",
    "category": "WSOD"
  },
  "actionTaken": "Deactivated plugin: elementor",
  "backup": {
    "id": "backup_abc123",
    "backupType": "FILE",
    "filePath": "/backups/site_abc123_20260213_100000.tar.gz",
    "fileSize": 1048576
  },
  "status": "SUCCESS",
  "logs": [
    {
      "timestamp": "2026-02-13T10:00:00Z",
      "level": "INFO",
      "message": "Starting healing execution"
    },
    {
      "timestamp": "2026-02-13T10:00:05Z",
      "level": "INFO",
      "message": "Diagnosis complete: WSOD caused by elementor plugin"
    },
    {
      "timestamp": "2026-02-13T10:00:10Z",
      "level": "INFO",
      "message": "Creating backup before healing"
    },
    {
      "timestamp": "2026-02-13T10:00:20Z",
      "level": "INFO",
      "message": "Executing: wp plugin deactivate elementor"
    },
    {
      "timestamp": "2026-02-13T10:00:35Z",
      "level": "INFO",
      "message": "Plugin deactivated successfully"
    },
    {
      "timestamp": "2026-02-13T10:00:40Z",
      "level": "INFO",
      "message": "Verifying site health"
    },
    {
      "timestamp": "2026-02-13T10:00:45Z",
      "level": "SUCCESS",
      "message": "Site is now healthy (HTTP 200)"
    }
  ],
  "preHealthScore": 20,
  "postHealthScore": 95,
  "wasSuccessful": true,
  "duration": 45000,
  "startedAt": "2026-02-13T10:00:00Z",
  "diagnosedAt": "2026-02-13T10:00:05Z",
  "healedAt": "2026-02-13T10:00:35Z",
  "verifiedAt": "2026-02-13T10:00:45Z",
  "finishedAt": "2026-02-13T10:00:45Z"
}
```

#### POST /api/v1/healer/executions/:id/rollback
Rollback a healing execution

**Response:** 200 OK
```json
{
  "success": true,
  "message": "Rollback completed successfully",
  "restoredFiles": [
    "wp-content/plugins/elementor"
  ],
  "healthScore": 95
}
```

---

### 5.3 Statistics & Analytics

#### GET /api/v1/healer/stats
Get healer statistics

**Query Parameters:**
- `startDate` (ISO date): Start date for stats
- `endDate` (ISO date): End date for stats
- `siteId` (string): Filter by site

**Response:** 200 OK
```json
{
  "totalSites": 150,
  "activeSites": 120,
  "totalHealings": 450,
  "successRate": 0.92,
  "avgHealingTime": 45000,
  "totalUptimeSaved": "72h 30m",
  "mttrReduction": 0.65,
  "byDiagnosisType": {
    "WSOD": 180,
    "DB_ERROR": 90,
    "MAINTENANCE": 120,
    "INTEGRITY": 30,
    "PERMISSION": 30
  },
  "byStatus": {
    "SUCCESS": 414,
    "FAILED": 36
  },
  "topIssues": [
    {
      "diagnosisType": "WSOD",
      "count": 180,
      "avgHealingTime": 40000
    },
    {
      "diagnosisType": "MAINTENANCE",
      "count": 120,
      "avgHealingTime": 15000
    }
  ],
  "healingTrend": [
    {
      "date": "2026-02-01",
      "healings": 15,
      "successRate": 0.93
    },
    {
      "date": "2026-02-02",
      "healings": 18,
      "successRate": 0.89
    }
  ]
}
```

---

### 5.4 Runbook Management

#### GET /api/v1/healer/runbooks
List available runbooks

**Response:** 200 OK
```json
{
  "data": [
    {
      "id": "runbook_wsod",
      "name": "WSOD Healer",
      "description": "Diagnose and fix White Screen of Death by deactivating faulty plugins",
      "category": "WSOD",
      "isActive": true,
      "priority": 90,
      "requiresBackup": true,
      "isDryRunnable": true,
      "stats": {
        "totalExecutions": 180,
        "successRate": 0.95,
        "avgDuration": 40000
      }
    },
    {
      "id": "runbook_maintenance",
      "name": "Maintenance Mode Healer",
      "description": "Remove stuck .maintenance file",
      "category": "MAINTENANCE",
      "isActive": true,
      "priority": 100,
      "requiresBackup": false,
      "isDryRunnable": true,
      "stats": {
        "totalExecutions": 120,
        "successRate": 0.99,
        "avgDuration": 15000
      }
    }
  ]
}
```

---


## 6. Healing Runbook Implementations

### 6.1 WSOD Healer Runbook

```typescript
@Injectable()
export class WsodHealerRunbook implements HealingRunbook {
  constructor(
    private readonly wpCliService: WpCliService,
    private readonly sshService: SshService,
    private readonly logParser: LogParserService,
  ) {}

  async execute(context: HealingContext): Promise<HealingResult> {
    const { site, diagnosis } = context;
    
    // Step 1: Enable WP_DEBUG if not already enabled
    await this.wpCliService.exec(site, 'config set WP_DEBUG true --raw');
    await this.wpCliService.exec(site, 'config set WP_DEBUG_LOG true --raw');
    
    // Step 2: Trigger the error to generate fresh log
    await this.httpService.get(site.domain);
    await this.sleep(2000); // Wait for log to be written
    
    // Step 3: Read and parse error log
    const logContent = await this.sshService.exec(
      site.serverId,
      `tail -n 50 ${site.path}/wp-content/debug.log`
    );
    
    const parsedDiagnosis = await this.logParser.diagnose(logContent);
    
    // Step 4: Take action based on diagnosis
    if (parsedDiagnosis.type === 'PLUGIN_FAULT') {
      // Deactivate specific plugin
      await this.wpCliService.exec(
        site,
        `plugin deactivate ${parsedDiagnosis.culprit}`
      );
      
      return {
        success: true,
        action: `Deactivated plugin: ${parsedDiagnosis.culprit}`,
        details: parsedDiagnosis
      };
    } else if (parsedDiagnosis.type === 'THEME_FAULT') {
      // Switch to default theme
      await this.wpCliService.exec(site, 'theme activate twentytwentyfour');
      
      return {
        success: true,
        action: 'Switched to default theme: twentytwentyfour',
        details: parsedDiagnosis
      };
    } else if (parsedDiagnosis.confidence < 0.7) {
      // Low confidence - activate safe mode (deactivate all plugins)
      await this.wpCliService.exec(site, 'plugin deactivate --all');
      
      return {
        success: true,
        action: 'Activated safe mode: deactivated all plugins',
        details: parsedDiagnosis
      };
    }
    
    return {
      success: false,
      action: 'Unable to determine root cause',
      details: parsedDiagnosis
    };
  }
  
  async verify(context: HealingContext): Promise<boolean> {
    const { site } = context;
    
    // Check if site returns HTTP 200
    const response = await this.httpService.get(site.domain);
    return response.status === 200;
  }
}
```

### 6.2 Maintenance Mode Healer Runbook

```typescript
@Injectable()
export class MaintenanceHealerRunbook implements HealingRunbook {
  constructor(
    private readonly sshService: SshService,
  ) {}

  async execute(context: HealingContext): Promise<HealingResult> {
    const { site } = context;
    
    // Check if .maintenance file exists
    const maintenanceFile = `${site.path}/.maintenance`;
    const exists = await this.sshService.exec(
      site.serverId,
      `test -f ${maintenanceFile} && echo "exists" || echo "not found"`
    );
    
    if (exists.trim() !== 'exists') {
      return {
        success: false,
        action: 'No .maintenance file found',
        details: { fileExists: false }
      };
    }
    
    // Check file age
    const fileAge = await this.sshService.exec(
      site.serverId,
      `stat -c %Y ${maintenanceFile}`
    );
    
    const ageInMinutes = (Date.now() / 1000 - parseInt(fileAge)) / 60;
    
    // Only remove if older than 10 minutes
    if (ageInMinutes < 10) {
      return {
        success: false,
        action: 'Maintenance file is recent, skipping removal',
        details: { ageInMinutes }
      };
    }
    
    // Remove .maintenance file
    await this.sshService.exec(
      site.serverId,
      `rm -f ${maintenanceFile}`
    );
    
    return {
      success: true,
      action: 'Removed stuck .maintenance file',
      details: { ageInMinutes }
    };
  }
  
  async verify(context: HealingContext): Promise<boolean> {
    const { site } = context;
    
    // Check if site returns HTTP 200 (not 503)
    const response = await this.httpService.get(site.domain);
    return response.status === 200;
  }
}
```

### 6.3 Database Healer Runbook

```typescript
@Injectable()
export class DatabaseHealerRunbook implements HealingRunbook {
  constructor(
    private readonly wpCliService: WpCliService,
    private readonly sshService: SshService,
  ) {}

  async execute(context: HealingContext): Promise<HealingResult> {
    const { site } = context;
    
    // Step 1: Check MySQL service status
    const mysqlStatus = await this.sshService.exec(
      site.serverId,
      'systemctl is-active mysql || systemctl is-active mariadb'
    );
    
    if (mysqlStatus.trim() !== 'active') {
      return {
        success: false,
        action: 'MySQL service is not running - requires manual intervention',
        details: { mysqlStatus: mysqlStatus.trim() }
      };
    }
    
    // Step 2: Verify wp-config.php credentials
    const dbTest = await this.wpCliService.exec(site, 'db check');
    
    if (dbTest.includes('Access denied')) {
      return {
        success: false,
        action: 'Database credentials are invalid - requires manual intervention',
        details: { error: 'Access denied' }
      };
    }
    
    // Step 3: Check and repair database
    const checkResult = await this.wpCliService.exec(site, 'db check');
    
    if (checkResult.includes('corrupt') || checkResult.includes('error')) {
      // Repair database
      await this.wpCliService.exec(site, 'db repair');
      
      return {
        success: true,
        action: 'Repaired corrupted database tables',
        details: { checkResult }
      };
    }
    
    // Step 4: Optimize database
    await this.wpCliService.exec(site, 'db optimize');
    
    return {
      success: true,
      action: 'Database checked and optimized',
      details: { checkResult }
    };
  }
  
  async verify(context: HealingContext): Promise<boolean> {
    const { site } = context;
    
    // Verify database connection
    const result = await this.wpCliService.exec(site, 'db check');
    return !result.includes('error');
  }
}
```

### 6.4 Core Integrity Healer Runbook

```typescript
@Injectable()
export class IntegrityHealerRunbook implements HealingRunbook {
  constructor(
    private readonly wpCliService: WpCliService,
    private readonly backupService: BackupService,
  ) {}

  async execute(context: HealingContext): Promise<HealingResult> {
    const { site } = context;
    
    // Step 1: Verify core checksums
    const verifyResult = await this.wpCliService.exec(
      site,
      'core verify-checksums'
    );
    
    if (verifyResult.includes('Success')) {
      return {
        success: true,
        action: 'Core files are intact',
        details: { verifyResult }
      };
    }
    
    // Step 2: Parse modified files
    const modifiedFiles = this.parseModifiedFiles(verifyResult);
    
    // Step 3: Create backup before restoration
    await this.backupService.backupFiles(site, modifiedFiles);
    
    // Step 4: Download and restore core files
    await this.wpCliService.exec(
      site,
      'core download --force --skip-content'
    );
    
    return {
      success: true,
      action: `Restored ${modifiedFiles.length} modified core files`,
      details: { modifiedFiles }
    };
  }
  
  async verify(context: HealingContext): Promise<boolean> {
    const { site } = context;
    
    // Verify checksums again
    const result = await this.wpCliService.exec(site, 'core verify-checksums');
    return result.includes('Success');
  }
  
  private parseModifiedFiles(output: string): string[] {
    const lines = output.split('\n');
    return lines
      .filter(line => line.includes('File should not exist') || line.includes('File doesn\'t verify'))
      .map(line => line.split(':')[1]?.trim())
      .filter(Boolean);
  }
}
```

### 6.5 Permission Healer Runbook

```typescript
@Injectable()
export class PermissionHealerRunbook implements HealingRunbook {
  constructor(
    private readonly sshService: SshService,
  ) {}

  async execute(context: HealingContext): Promise<HealingResult> {
    const { site } = context;
    
    // Step 1: Detect web server user
    const webUser = await this.detectWebServerUser(site.serverId);
    
    // Step 2: Fix directory permissions (755)
    await this.sshService.exec(
      site.serverId,
      `find ${site.path} -type d -exec chmod 755 {} \\;`
    );
    
    // Step 3: Fix file permissions (644)
    await this.sshService.exec(
      site.serverId,
      `find ${site.path} -type f -exec chmod 644 {} \\;`
    );
    
    // Step 4: Fix ownership
    if (site.cPanelUsername) {
      await this.sshService.exec(
        site.serverId,
        `chown -R ${site.cPanelUsername}:${site.cPanelUsername} ${site.path}`
      );
    } else {
      await this.sshService.exec(
        site.serverId,
        `chown -R ${webUser}:${webUser} ${site.path}`
      );
    }
    
    // Step 5: Fix wp-content permissions (775 for uploads)
    await this.sshService.exec(
      site.serverId,
      `chmod -R 775 ${site.path}/wp-content/uploads`
    );
    
    return {
      success: true,
      action: 'Fixed file permissions and ownership',
      details: { webUser, owner: site.cPanelUsername || webUser }
    };
  }
  
  async verify(context: HealingContext): Promise<boolean> {
    const { site } = context;
    
    // Check if site returns HTTP 200 (not 403)
    const response = await this.httpService.get(site.domain);
    return response.status === 200;
  }
  
  private async detectWebServerUser(serverId: string): Promise<string> {
    // Try common web server users
    const users = ['www-data', 'apache', 'nginx', 'httpd'];
    
    for (const user of users) {
      const result = await this.sshService.exec(
        serverId,
        `id ${user} 2>/dev/null && echo "exists" || echo "not found"`
      );
      
      if (result.includes('exists')) {
        return user;
      }
    }
    
    return 'www-data'; // Default fallback
  }
}
```

---

## 7. Integration with Other Modules

### 7.1 Module 2 (Server Connections)

**Integration Points:**
- SSH connection for wp-cli execution
- Credential decryption for server access
- Connection testing before healing
- Privilege escalation (sudo) for system commands

**Implementation:**
```typescript
@Injectable()
export class WpCliService {
  constructor(
    private readonly sshService: SshService, // From Module 2
  ) {}
  
  async exec(site: WpSite, command: string): Promise<string> {
    const fullCommand = `cd ${site.path} && wp ${command}`;
    
    return await this.sshService.exec(
      site.serverId,
      fullCommand,
      { timeout: 60000 }
    );
  }
}
```

### 7.2 Module 3 (Integration Hub)

**Integration Points:**
- WHM integration for site discovery
- cPanel account management
- Site metadata extraction

**Implementation:**
```typescript
@Injectable()
export class SiteDiscoveryService {
  constructor(
    private readonly integrationService: IntegrationService, // From Module 3
  ) {}
  
  async discoverSites(integrationId: string): Promise<WpSite[]> {
    const client = await this.integrationService.getClient(integrationId, 'WHM');
    
    // List all cPanel accounts
    const accounts = await client.listAccounts();
    
    const sites: WpSite[] = [];
    
    for (const account of accounts) {
      // Check if WordPress is installed
      const wpPath = `/home/${account.user}/public_html`;
      const hasWp = await this.checkWordPressInstallation(wpPath);
      
      if (hasWp) {
        sites.push({
          domain: account.domain,
          path: wpPath,
          cPanelUsername: account.user,
          // ... other fields
        });
      }
    }
    
    return sites;
  }
}
```

### 7.3 Module 5 (Automation)

**Integration Points:**
- Healing runbooks as automation playbooks
- Shared execution engine
- Retry logic and circuit breakers

**Implementation:**
```typescript
// Healing runbooks extend automation playbooks
export abstract class HealingRunbook extends AutomationPlaybook {
  abstract execute(context: HealingContext): Promise<HealingResult>;
  abstract verify(context: HealingContext): Promise<boolean>;
  
  async rollback(context: HealingContext): Promise<void> {
    // Restore from backup
    await this.backupService.restore(context.backup);
  }
}
```

### 7.4 Module 6 (Incident Management)

**Integration Points:**
- Incident-triggered healing
- Healing result â†’ incident update
- Automatic incident resolution
- Escalation on healing failure

**Implementation:**
```typescript
@Injectable()
export class IncidentHealingService {
  constructor(
    private readonly healerOrchestrator: HealerOrchestrator,
    private readonly incidentService: IncidentService, // From Module 6
  ) {}
  
  async handleIncident(incident: Incident): Promise<void> {
    // Check if incident is healable
    if (!this.isHealable(incident)) {
      return;
    }
    
    // Trigger healing
    const result = await this.healerOrchestrator.heal(
      incident.siteId,
      { trigger: 'INCIDENT', incidentId: incident.id }
    );
    
    // Update incident based on result
    if (result.status === 'SUCCESS') {
      await this.incidentService.resolve(incident.id, {
        resolution: `Auto-healed: ${result.action}`,
        resolvedBy: 'SYSTEM'
      });
    } else if (result.status === 'FAILED') {
      await this.incidentService.escalate(incident.id, {
        reason: `Healing failed: ${result.errorMessage}`,
        severity: 'CRITICAL'
      });
    }
  }
}
```

### 7.5 Module 7 (Logging & Event Store)

**Integration Points:**
- Structured logging for all healing steps
- Distributed tracing for healing workflows
- Healing metrics and analytics
- Audit trail

**Implementation:**
```typescript
@Injectable()
export class HealerOrchestrator {
  constructor(
    private readonly logger: LoggerService, // From Module 7
  ) {}
  
  async heal(siteId: string, trigger: HealerTrigger): Promise<HealerResult> {
    const traceId = this.logger.startTrace('healer.heal');
    
    this.logger.info('Starting healing execution', {
      traceId,
      siteId,
      trigger,
      context: 'healer.orchestrator'
    });
    
    try {
      // ... healing logic
      
      this.logger.info('Healing completed successfully', {
        traceId,
        siteId,
        duration: Date.now() - startTime,
        context: 'healer.orchestrator'
      });
      
      return result;
    } catch (error) {
      this.logger.error('Healing failed', {
        traceId,
        siteId,
        error: error.message,
        stack: error.stack,
        context: 'healer.orchestrator'
      });
      
      throw error;
    } finally {
      this.logger.endTrace(traceId);
    }
  }
}
```

---


## 8. Security & Safety Considerations

### 8.1 The "Do No Harm" Protocol

Automated systems can spiral out of control. We implement strict safety measures:

#### 8.1.1 Rate Limiting
```typescript
@Injectable()
export class HealingRateLimiter {
  constructor(private readonly redis: Redis) {}
  
  async canHeal(siteId: string): Promise<boolean> {
    const key = `healer:ratelimit:${siteId}`;
    const lastHealing = await this.redis.get(key);
    
    if (!lastHealing) {
      return true;
    }
    
    const cooldown = 1800; // 30 minutes in seconds
    const elapsed = Date.now() / 1000 - parseInt(lastHealing);
    
    return elapsed >= cooldown;
  }
  
  async recordHealing(siteId: string): Promise<void> {
    const key = `healer:ratelimit:${siteId}`;
    const timestamp = Math.floor(Date.now() / 1000);
    
    await this.redis.set(key, timestamp.toString(), 'EX', 7200); // 2 hours TTL
  }
}
```

#### 8.1.2 Circuit Breaker
```typescript
@Injectable()
export class HealingCircuitBreaker {
  async checkCircuit(siteId: string): Promise<CircuitState> {
    const attempts = await this.getHealingAttempts(siteId, '24h');
    const maxAttempts = 3;
    
    if (attempts >= maxAttempts) {
      return {
        state: 'OPEN',
        reason: `Max healing attempts (${maxAttempts}) reached in 24h`,
        action: 'ESCALATE_TO_HUMAN'
      };
    }
    
    return {
      state: 'CLOSED',
      reason: 'Circuit is healthy',
      action: 'PROCEED'
    };
  }
}
```

#### 8.1.3 Backup Before Mutation
```typescript
@Injectable()
export class BackupService {
  async backupBeforeHealing(site: WpSite, runbook: HealerRunbook): Promise<HealerBackup> {
    if (!runbook.requiresBackup) {
      return null;
    }
    
    const timestamp = Date.now();
    const backupPath = `/backups/${site.id}_${timestamp}`;
    
    // Backup files that will be modified
    if (runbook.category === 'WSOD' || runbook.category === 'PLUGIN') {
      await this.backupPlugins(site, backupPath);
    }
    
    if (runbook.category === 'DATABASE') {
      await this.backupDatabase(site, backupPath);
    }
    
    if (runbook.category === 'INTEGRITY') {
      await this.backupCoreFiles(site, backupPath);
    }
    
    return await this.prisma.healerBackup.create({
      data: {
        siteId: site.id,
        backupType: this.getBackupType(runbook),
        filePath: backupPath,
        status: 'COMPLETED',
        expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000) // 7 days
      }
    });
  }
  
  async restore(backup: HealerBackup): Promise<void> {
    // Restore files from backup
    await this.sshService.exec(
      backup.site.serverId,
      `tar -xzf ${backup.filePath} -C ${backup.site.path}`
    );
  }
}
```

### 8.2 Credential Isolation

The Healer module does **not** store WordPress admin passwords. It operates purely via:
- SSH keys (Module 2) for server access
- `wp-cli` for WordPress operations (bypasses WP authentication)
- WHM API (Module 3) for cPanel operations

This is significantly more secure than storing user credentials.

### 8.3 Command Sanitization

```typescript
@Injectable()
export class WpCliService {
  private readonly ALLOWED_COMMANDS = [
    'plugin',
    'theme',
    'config',
    'db',
    'core',
    'cache',
    'transient',
    'option'
  ];
  
  async exec(site: WpSite, command: string): Promise<string> {
    // Validate command
    const [mainCommand] = command.split(' ');
    
    if (!this.ALLOWED_COMMANDS.includes(mainCommand)) {
      throw new Error(`Command not allowed: ${mainCommand}`);
    }
    
    // Sanitize input
    const sanitized = this.sanitizeCommand(command);
    
    // Execute with timeout
    return await this.sshService.exec(
      site.serverId,
      `cd ${site.path} && wp ${sanitized}`,
      { timeout: 60000 }
    );
  }
  
  private sanitizeCommand(command: string): string {
    // Remove dangerous characters
    return command
      .replace(/[;&|`$()]/g, '')
      .replace(/\.\./g, '')
      .trim();
  }
}
```

### 8.4 Audit Logging

Every healing action is logged to Module 7:

```typescript
@Injectable()
export class HealerAuditService {
  constructor(private readonly logger: LoggerService) {}
  
  async logHealingAttempt(execution: HealerExecution): Promise<void> {
    await this.logger.audit({
      action: 'HEALING_ATTEMPT',
      actor: execution.triggeredBy || 'SYSTEM',
      resource: `site:${execution.siteId}`,
      details: {
        executionId: execution.id,
        diagnosisType: execution.diagnosisType,
        runbookId: execution.runbookId,
        trigger: execution.trigger
      },
      severity: 'INFO',
      context: 'healer.audit'
    });
  }
  
  async logHealingResult(execution: HealerExecution): Promise<void> {
    await this.logger.audit({
      action: execution.status === 'SUCCESS' ? 'HEALING_SUCCESS' : 'HEALING_FAILURE',
      actor: execution.triggeredBy || 'SYSTEM',
      resource: `site:${execution.siteId}`,
      details: {
        executionId: execution.id,
        status: execution.status,
        actionTaken: execution.actionTaken,
        duration: execution.duration,
        preHealthScore: execution.preHealthScore,
        postHealthScore: execution.postHealthScore
      },
      severity: execution.status === 'SUCCESS' ? 'INFO' : 'WARNING',
      context: 'healer.audit'
    });
  }
}
```

---

## 9. Performance Requirements

| Operation | Target | Max | Notes |
|-----------|--------|-----|-------|
| **Site Discovery** | < 30s | 60s | Per WHM server |
| **Health Check** | < 2s | 5s | HTTP + basic checks |
| **Diagnosis** | < 5s | 15s | Log parsing + analysis |
| **WSOD Healing** | < 30s | 60s | Plugin deactivation |
| **Maintenance Healing** | < 10s | 20s | File removal |
| **Database Healing** | < 45s | 90s | Check + repair |
| **Integrity Healing** | < 60s | 120s | Core file restoration |
| **Permission Healing** | < 30s | 60s | Recursive chmod/chown |
| **Backup Creation** | < 20s | 45s | File/DB backup |
| **Rollback** | < 30s | 60s | Restore from backup |

### Performance Optimization Strategies

1. **Parallel Execution:** Run health checks in parallel for multiple sites
2. **Caching:** Cache diagnosis results for 5 minutes
3. **Connection Pooling:** Reuse SSH connections
4. **Async Processing:** Use BullMQ for non-blocking healing
5. **Incremental Backups:** Only backup modified files

---

## 10. Success Metrics (KPIs)

### 10.1 Functional Metrics

- âœ… **Auto-Resolution Rate:** >40% of WP-related incidents resolved without human intervention
- âœ… **Diagnosis Accuracy:** >90% correct diagnosis
- âœ… **Healing Success Rate:** >92% successful healings
- âœ… **False Positives:** <1% (Healer should not take action if site is fine)
- âœ… **Safety:** 100% of file modifications have recoverable backup
- âœ… **Zero Destructive Operations:** No data loss incidents

### 10.2 Performance Metrics

- âœ… **Mean Time To Recovery (MTTR):** Reduced from ~45 mins (Human) to <2 mins (Healer)
- âœ… **MTTR Reduction:** >60% improvement
- âœ… **Average Healing Time:** <45 seconds
- âœ… **Uptime Saved:** >70 hours per month (for 150 sites)
- âœ… **API Response Time:** <200ms (p95)

### 10.3 Business Metrics

- âœ… **Support Ticket Reduction:** 40-50% fewer WP-related tickets
- âœ… **Customer Satisfaction:** >4.5/5 rating
- âœ… **Cost Savings:** $10,000+ per month in support costs
- âœ… **Operational Efficiency:** 80% reduction in manual SSH debugging

### 10.4 SRE Metrics

- âœ… **Error Budget Consumption:** <5% per month
- âœ… **SLO Compliance:** >99.5% uptime for healer service
- âœ… **Incident Escalation Rate:** <8% (healing failures requiring human intervention)
- âœ… **Rollback Rate:** <3% (healings requiring rollback)

---

## 11. Testing Strategy

### 11.1 Unit Tests (>80% Coverage)

```typescript
describe('WsodHealerRunbook', () => {
  let runbook: WsodHealerRunbook;
  let wpCliService: jest.Mocked<WpCliService>;
  let logParser: jest.Mocked<LogParserService>;
  
  beforeEach(() => {
    wpCliService = createMock<WpCliService>();
    logParser = createMock<LogParserService>();
    runbook = new WsodHealerRunbook(wpCliService, logParser);
  });
  
  describe('execute', () => {
    it('should deactivate faulty plugin when diagnosis is PLUGIN_FAULT', async () => {
      // Arrange
      const site = createMockSite();
      const context = { site, diagnosis: { type: 'WSOD' } };
      
      logParser.diagnose.mockResolvedValue({
        type: 'PLUGIN_FAULT',
        culprit: 'elementor',
        confidence: 0.95
      });
      
      wpCliService.exec.mockResolvedValue('Success');
      
      // Act
      const result = await runbook.execute(context);
      
      // Assert
      expect(result.success).toBe(true);
      expect(result.action).toContain('Deactivated plugin: elementor');
      expect(wpCliService.exec).toHaveBeenCalledWith(
        site,
        'plugin deactivate elementor'
      );
    });
    
    it('should activate safe mode when confidence is low', async () => {
      // Arrange
      const site = createMockSite();
      const context = { site, diagnosis: { type: 'WSOD' } };
      
      logParser.diagnose.mockResolvedValue({
        type: 'UNKNOWN',
        confidence: 0.5
      });
      
      wpCliService.exec.mockResolvedValue('Success');
      
      // Act
      const result = await runbook.execute(context);
      
      // Assert
      expect(result.success).toBe(true);
      expect(result.action).toContain('safe mode');
      expect(wpCliService.exec).toHaveBeenCalledWith(
        site,
        'plugin deactivate --all'
      );
    });
  });
});
```

### 11.2 Integration Tests

```typescript
describe('HealerOrchestrator Integration', () => {
  let orchestrator: HealerOrchestrator;
  let testSite: WpSite;
  
  beforeAll(async () => {
    // Setup test database
    await setupTestDatabase();
    
    // Create test site
    testSite = await createTestSite({
      domain: 'test.example.com',
      path: '/var/www/test',
      isHealerEnabled: true
    });
  });
  
  it('should complete full healing workflow', async () => {
    // Trigger healing
    const result = await orchestrator.heal(testSite.id, {
      trigger: 'MANUAL'
    });
    
    // Verify execution was created
    const execution = await prisma.healerExecution.findUnique({
      where: { id: result.executionId }
    });
    
    expect(execution).toBeDefined();
    expect(execution.status).toBe('SUCCESS');
    expect(execution.duration).toBeLessThan(60000);
    
    // Verify site health improved
    const updatedSite = await prisma.wpSite.findUnique({
      where: { id: testSite.id }
    });
    
    expect(updatedSite.healthStatus).toBe('HEALTHY');
    expect(updatedSite.healthScore).toBeGreaterThan(90);
  });
});
```

### 11.3 E2E Tests

```typescript
describe('Healer E2E', () => {
  it('should heal WSOD caused by faulty plugin', async () => {
    // 1. Setup: Create site with faulty plugin
    const site = await setupTestSite({
      plugins: ['elementor-broken']
    });
    
    // 2. Verify site is down
    const healthCheck = await checkSiteHealth(site.domain);
    expect(healthCheck.status).toBe(500);
    
    // 3. Trigger healing via API
    const response = await request(app.getHttpServer())
      .post(`/api/v1/healer/sites/${site.id}/heal`)
      .set('Authorization', `Bearer ${authToken}`)
      .send({ force: true });
    
    expect(response.status).toBe(202);
    
    // 4. Wait for healing to complete
    await waitForExecution(response.body.executionId, 60000);
    
    // 5. Verify site is now healthy
    const finalHealthCheck = await checkSiteHealth(site.domain);
    expect(finalHealthCheck.status).toBe(200);
    
    // 6. Verify execution record
    const execution = await getExecution(response.body.executionId);
    expect(execution.status).toBe('SUCCESS');
    expect(execution.actionTaken).toContain('Deactivated plugin');
  });
});
```

---


## 12. Deployment & Operations

### 12.1 Environment Variables

```bash
# Healer Configuration
HEALER_ENABLED=true
HEALER_MAX_CONCURRENT_HEALINGS=5
HEALER_DEFAULT_COOLDOWN=1800 # 30 minutes
HEALER_MAX_ATTEMPTS_PER_DAY=3
HEALER_BACKUP_RETENTION_DAYS=7

# BullMQ Configuration
REDIS_URL=redis://localhost:6379
HEALER_QUEUE_NAME=healer-jobs
HEALER_QUEUE_CONCURRENCY=3

# Safety Configuration
HEALER_DRY_RUN_MODE=false
HEALER_REQUIRE_BACKUP=true
HEALER_AUTO_ESCALATE=true

# Monitoring
HEALER_METRICS_ENABLED=true
HEALER_TRACE_ENABLED=true
```

### 12.2 Database Migrations

```bash
# Create initial schema
npx prisma migrate dev --name init-healer-module

# Add indexes for performance
npx prisma migrate dev --name add-healer-indexes

# Add custom healing rules
npx prisma migrate dev --name add-healer-rules
```

### 12.3 Seed Data (Runbooks)

```typescript
// prisma/seeds/healer-runbooks.ts
export const healerRunbooks = [
  {
    name: 'WSOD Healer',
    description: 'Diagnose and fix White Screen of Death by deactivating faulty plugins',
    category: 'WSOD',
    isActive: true,
    priority: 90,
    requiresBackup: true,
    isDryRunnable: true,
    maxRetries: 3,
    timeout: 60,
    handlerClass: 'WsodHealerRunbook'
  },
  {
    name: 'Maintenance Mode Healer',
    description: 'Remove stuck .maintenance file',
    category: 'MAINTENANCE',
    isActive: true,
    priority: 100,
    requiresBackup: false,
    isDryRunnable: true,
    maxRetries: 1,
    timeout: 20,
    handlerClass: 'MaintenanceHealerRunbook'
  },
  {
    name: 'Database Healer',
    description: 'Check and repair database issues',
    category: 'DATABASE',
    isActive: true,
    priority: 80,
    requiresBackup: true,
    isDryRunnable: false,
    maxRetries: 2,
    timeout: 90,
    handlerClass: 'DatabaseHealerRunbook'
  },
  {
    name: 'Core Integrity Healer',
    description: 'Verify and restore WordPress core files',
    category: 'INTEGRITY',
    isActive: true,
    priority: 70,
    requiresBackup: true,
    isDryRunnable: true,
    maxRetries: 2,
    timeout: 120,
    handlerClass: 'IntegrityHealerRunbook'
  },
  {
    name: 'Permission Healer',
    description: 'Fix file permissions and ownership',
    category: 'PERMISSION',
    isActive: true,
    priority: 60,
    requiresBackup: false,
    isDryRunnable: true,
    maxRetries: 2,
    timeout: 60,
    handlerClass: 'PermissionHealerRunbook'
  },
  {
    name: 'Cache Healer',
    description: 'Clear object cache and transients',
    category: 'CACHE',
    isActive: true,
    priority: 50,
    requiresBackup: false,
    isDryRunnable: true,
    maxRetries: 1,
    timeout: 30,
    handlerClass: 'CacheHealerRunbook'
  }
];
```

### 12.4 Monitoring & Alerting

```typescript
// Prometheus Metrics
@Injectable()
export class HealerMetricsService {
  private readonly healingAttempts = new Counter({
    name: 'healer_attempts_total',
    help: 'Total number of healing attempts',
    labelNames: ['site_id', 'diagnosis_type', 'status']
  });
  
  private readonly healingDuration = new Histogram({
    name: 'healer_duration_seconds',
    help: 'Healing execution duration',
    labelNames: ['site_id', 'runbook_id'],
    buckets: [5, 10, 30, 60, 120]
  });
  
  private readonly healthScore = new Gauge({
    name: 'healer_site_health_score',
    help: 'Current health score of sites',
    labelNames: ['site_id', 'domain']
  });
  
  recordHealingAttempt(execution: HealerExecution): void {
    this.healingAttempts.inc({
      site_id: execution.siteId,
      diagnosis_type: execution.diagnosisType,
      status: execution.status
    });
  }
  
  recordHealingDuration(execution: HealerExecution): void {
    this.healingDuration.observe(
      {
        site_id: execution.siteId,
        runbook_id: execution.runbookId
      },
      execution.duration / 1000
    );
  }
  
  updateHealthScore(site: WpSite): void {
    this.healthScore.set(
      {
        site_id: site.id,
        domain: site.domain
      },
      site.healthScore || 0
    );
  }
}
```

### 12.5 Grafana Dashboard

```json
{
  "dashboard": {
    "title": "WordPress Auto-Healer",
    "panels": [
      {
        "title": "Healing Success Rate",
        "targets": [
          {
            "expr": "rate(healer_attempts_total{status=\"SUCCESS\"}[5m]) / rate(healer_attempts_total[5m])"
          }
        ]
      },
      {
        "title": "Average Healing Time",
        "targets": [
          {
            "expr": "histogram_quantile(0.95, rate(healer_duration_seconds_bucket[5m]))"
          }
        ]
      },
      {
        "title": "Healings by Diagnosis Type",
        "targets": [
          {
            "expr": "sum by (diagnosis_type) (rate(healer_attempts_total[5m]))"
          }
        ]
      },
      {
        "title": "Site Health Scores",
        "targets": [
          {
            "expr": "healer_site_health_score"
          }
        ]
      }
    ]
  }
}
```

---

## 13. Documentation Deliverables

### 13.1 Technical Documentation

- [ ] **Architecture Diagrams**
  - System architecture
  - Healing workflow
  - Integration points
  - Database schema

- [ ] **API Documentation (Swagger)**
  - All endpoints documented
  - Request/response examples
  - Error codes and handling
  - Authentication requirements

- [ ] **Runbook Documentation**
  - Each runbook's purpose
  - Execution logic
  - Safety measures
  - Rollback procedures

- [ ] **Integration Guide**
  - Module 2 (SSH) integration
  - Module 3 (WHM) integration
  - Module 5 (Automation) integration
  - Module 6 (Incidents) integration
  - Module 7 (Logging) integration

### 13.2 User Documentation

- [ ] **Site Registration Guide**
  - How to register WordPress sites
  - Configuration options
  - Best practices

- [ ] **Healing Configuration Guide**
  - Enable/disable auto-healing
  - Configure healing attempts
  - Manage plugin blacklists
  - Set up custom rules

- [ ] **Troubleshooting Guide**
  - Common issues and solutions
  - Healing failure scenarios
  - Rollback procedures
  - Manual intervention steps

- [ ] **Best Practices Guide**
  - When to enable auto-healing
  - Safety considerations
  - Monitoring recommendations
  - Backup strategies

### 13.3 Operational Documentation

- [ ] **Deployment Guide**
  - Environment setup
  - Database migrations
  - Seed data
  - Configuration

- [ ] **Monitoring Guide**
  - Metrics to track
  - Alert thresholds
  - Dashboard setup
  - Log analysis

- [ ] **Incident Response Guide**
  - Healing failure response
  - Escalation procedures
  - Rollback procedures
  - Communication templates

---

## 14. Future Enhancements (Phase 2)

### 14.1 Advanced Diagnosis

- **Machine Learning:** Train ML model on healing history to improve diagnosis accuracy
- **Predictive Healing:** Detect issues before they cause downtime
- **Pattern Recognition:** Identify recurring issues across sites
- **Anomaly Detection:** Detect unusual behavior patterns

### 14.2 Additional Runbooks

- **Plugin Update Healer:** Automatically update plugins causing issues
- **Theme Update Healer:** Automatically update themes
- **Security Healer:** Detect and remove malware
- **Performance Healer:** Optimize slow sites
- **SEO Healer:** Fix common SEO issues

### 14.3 Enhanced Integrations

- **Cloudflare Integration:** Purge CDN cache after healing
- **Backup Integration:** Integrate with backup services (UpdraftPlus, BackupBuddy)
- **Monitoring Integration:** Integrate with UptimeRobot, Pingdom
- **Slack Integration:** Real-time healing notifications

### 14.4 Advanced Features

- **Healing Recommendations:** Suggest preventive actions
- **Cost Analysis:** Calculate cost savings from auto-healing
- **Healing Playbooks:** User-defined healing workflows
- **A/B Testing:** Test different healing strategies
- **Healing Simulation:** Dry-run mode with detailed preview

---

## 15. Risk Management

### 15.1 Technical Risks

| Risk | Impact | Probability | Mitigation |
|------|--------|-------------|------------|
| Healing causes data loss | Critical | Low | Mandatory backups, rollback capability |
| Healing loops (repeated failures) | High | Medium | Circuit breaker, rate limiting |
| SSH connection failures | Medium | Medium | Connection pooling, retry logic |
| wp-cli not installed | Medium | Low | Detection during site registration |
| Incorrect diagnosis | Medium | Medium | Confidence scoring, manual override |
| Performance degradation | Medium | Low | Async processing, queue management |

### 15.2 Business Risks

| Risk | Impact | Probability | Mitigation |
|------|--------|-------------|------------|
| Customer distrust of automation | High | Medium | Transparency, manual controls, audit logs |
| Over-reliance on automation | Medium | High | Human oversight, escalation policies |
| Healing false positives | Medium | Medium | Confidence thresholds, dry-run mode |
| Support team skill degradation | Low | Medium | Training, documentation, manual tools |

### 15.3 Mitigation Strategies

1. **Gradual Rollout:** Start with low-risk sites, expand gradually
2. **Monitoring:** Comprehensive metrics and alerting
3. **Transparency:** Clear communication about healing actions
4. **Manual Override:** Always allow manual control
5. **Audit Trail:** Complete logging of all actions
6. **Rollback:** Quick rollback capability
7. **Training:** Train support team on healer operations

---

## 16. Acceptance Criteria

### 16.1 Functional Criteria

- [ ] Admin can register WordPress sites for healing
- [ ] System can discover WordPress sites from WHM
- [ ] Health monitoring runs every 5 minutes
- [ ] Diagnosis engine correctly identifies 6 issue types
- [ ] All 6 core runbooks are implemented and functional
- [ ] Healing can be triggered manually or automatically
- [ ] Backups are created before healing
- [ ] Rollback functionality works correctly
- [ ] Rate limiting prevents healing loops
- [ ] Circuit breaker escalates after max attempts
- [ ] Integration with Module 6 (Incidents) works
- [ ] Integration with Module 7 (Logging) works
- [ ] REST API is complete and documented
- [ ] Frontend UI is functional and intuitive

### 16.2 Performance Criteria

- [ ] Health check completes in <2s
- [ ] Diagnosis completes in <5s
- [ ] WSOD healing completes in <30s
- [ ] Maintenance healing completes in <10s
- [ ] Database healing completes in <45s
- [ ] API response time <200ms (p95)
- [ ] System handles 100+ concurrent sites

### 16.3 Quality Criteria

- [ ] Unit test coverage >80%
- [ ] Integration test coverage >70%
- [ ] E2E tests for critical flows
- [ ] Zero critical security vulnerabilities
- [ ] All code passes linting
- [ ] All APIs documented in Swagger
- [ ] User documentation complete

### 16.4 Success Criteria

- [ ] Auto-resolution rate >40%
- [ ] Healing success rate >92%
- [ ] MTTR reduction >60%
- [ ] Zero data loss incidents
- [ ] Support ticket reduction >40%
- [ ] Customer satisfaction >4.5/5

---

## 17. Conclusion

Module 4 (WordPress Auto-Healer) is the differentiator that transforms OpsManager from a passive monitoring tool into an active **Application Reliability Platform**. By leveraging intelligent diagnosis, surgical remediation, and comprehensive safety measures, we provide an "Autopilot" for WordPress hosting that drastically reduces operational toil and improves customer satisfaction.

### Key Differentiators

1. **Surgical Precision:** Uses wp-cli to target specific issues, not generic restarts
2. **Safety First:** Mandatory backups, rollback capability, circuit breakers
3. **Observable:** Full integration with Module 7 for distributed tracing
4. **Extensible:** Runbook framework allows easy addition of new healers
5. **SRE-Focused:** MTTR reduction, error budgets, blameless postmortems

### Business Impact

- **40-50% reduction** in support tickets
- **60% reduction** in MTTR
- **$10,000+ monthly savings** in support costs
- **>70 hours** of uptime saved per month
- **4.5/5** customer satisfaction rating

### Next Steps

1. Review and approve this implementation plan
2. Assemble the implementation team (2-3 backend, 1 frontend)
3. Setup development environment
4. Begin Sprint 1: Core Infrastructure & Site Management

---

**Document Control:**
- **Version:** 2.0.0
- **Last Updated:** February 13, 2026
- **Next Review:** March 13, 2026
- **Owner:** Engineering Leadership
- **Status:** Ready for Implementation

