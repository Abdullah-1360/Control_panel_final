# Module 8: Notification & Communication Bus (SRE Alerting)
## Professional Implementation Plan

**Version:** 3.0.0  
**Status:** Ready for Implementation  
**Dependencies:** Module 1 (Auth), Module 5 (Automation), Module 6 (Incidents), Module 7 (Logging)  
**Estimated Duration:** 3 weeks (120 hours)  
**Team Size:** 2 developers

---

## ðŸŽ¯ IMPLEMENTATION DECISIONS (Feb 11, 2026)

**Channels (Phase 1):** Email + Webhook + PagerDuty (SMS via AWS SNS)  
**Channels (Deferred):** Slack, Discord, Teams  
**Debouncing:** 30s window, 1h cooldown  
**Retry:** 3 attempts with exponential backoff  
**Rate Limiting:** 100/hour, 1000/day per channel  
**Encryption:** libsodium-wrappers for channel credentials  
**SRE Focus:** On-call management, escalation policies, alert fatigue prevention

---

## 1. Executive Summary

### 1.1 Business Value
The Notification & Communication Bus (SRE Alerting) decouples event generation from message delivery, providing intelligent routing, multi-channel delivery, on-call management, and alert fatigue prevention. This module ensures critical information reaches the right people through the right channels at the right time, following Site Reliability Engineering best practices for incident alerting and escalation.

**Key Outcomes:** Intelligent alert routing, multi-channel delivery (Email, PagerDuty, Slack, Discord, SMS, Webhook), alert fatigue prevention through debouncing (80% reduction target), guaranteed delivery with retry logic, comprehensive audit trail, on-call rotation management, escalation policies.

### 1.2 Technical Highlights
- Multi-channel adapter pattern (Email, PagerDuty, Slack, Discord, SMS, Webhook)
- BullMQ job queue for reliable async delivery
- Intelligent routing engine with priority-based rules
- Anti-flap debouncing to prevent alert spam
- Template engine with variable substitution
- Retry logic with exponential backoff
- Rate limiting per channel
- Encrypted credential storage
- **On-call schedule management**
- **Escalation policy engine**
- **Alert grouping and suppression**

### 1.3 Core Concepts
**Channel:** Delivery mechanism (SMTP, PagerDuty API, Slack webhook, etc.) | **Route:** Rule mapping events to channels | **Template:** Message blueprint with variables | **Debounce:** Alert grouping to prevent spam | **Adapter Pattern:** Unified interface for all channels | **Job Queue:** Async delivery with retries | **On-Call Schedule:** Rotation of engineers responsible for alerts | **Escalation Policy:** Rules for escalating unacknowledged alerts | **Alert Grouping:** Combining related alerts to reduce noise

---

## 2. Implementation Roadmap

### Sprint 1: Core Infrastructure (Week 1)
- Database schema (Channel, Rule, Log)
- NotificationService with job queue
- Adapter pattern interface
- Email adapter (Nodemailer)
- Slack adapter
- Unit tests (>85% coverage)

### Sprint 2: Routing & Intelligence (Week 2)
- Routing engine with rule evaluation
- Debouncing service (Redis-based)
- Rate limiting per channel
- Template engine with variables
- Discord and Webhook adapters
- Integration tests

### Sprint 3: API & Frontend (Week 3)
- REST API for channel/rule management
- Channel testing functionality
- Notification history UI
- Channel configuration UI
- Rule builder UI
- E2E tests

---

## 3. Technical Architecture

**Flow:** Event Emitted â†’ NotificationService â†’ Routing Engine â†’ Debounce Check â†’ BullMQ Job â†’ Channel Adapter â†’ Delivery â†’ Audit Log

---

## 4. Database Schema

```prisma
model NotificationChannel {
  id              String   @id @default(uuid())
  
  // Identity
  name            String
  description     String?  @db.Text
  type            ChannelType
  
  // Configuration (encrypted)
  encryptedConfig String   @db.Text
  
  // Settings
  isEnabled       Boolean  @default(true)
  isGlobal        Boolean  @default(true)
  ownerId         String?
  owner           User?    @relation(fields: [ownerId], references: [id])
  
  // Rate Limiting
  maxPerHour      Int      @default(100)
  maxPerDay       Int      @default(1000)
  
  // Statistics
  successCount    Int      @default(0)
  failureCount    Int      @default(0)
  lastUsedAt      DateTime?
  lastFailureAt   DateTime?
  
  // Relations
  rules           NotificationRule[]
  logs            NotificationLog[]
  
  // Timestamps
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  @@index([type])
  @@index([isEnabled])
  @@map("notification_channels")
}

enum ChannelType {
  EMAIL
  SLACK
  DISCORD
  WEBHOOK
  SMS
  TEAMS
}

model NotificationRule {
  id              String   @id @default(uuid())
  
  // Identity
  name            String
  description     String?  @db.Text
  priority        Int      @default(0)
  isEnabled       Boolean  @default(true)
  
  // Conditions
  eventTypes      String[] // ['INCIDENT_CREATED', 'AUTOMATION_FAILED']
  minSeverity     Severity?
  sourceModules   String[] // ['INCIDENT', 'AUTOMATION']
  
  // Advanced Conditions (JSONB)
  conditions      Json?    // { "metadata.assetType": "PRODUCTION" }
  
  // Target
  channelId       String
  channel         NotificationChannel @relation(fields: [channelId], references: [id])
  
  // Template
  templateId      String?
  customTemplate  String?  @db.Text
  
  // Timestamps
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  @@index([priority])
  @@index([isEnabled])
  @@map("notification_rules")
}

model NotificationLog {
  id              String   @id @default(uuid())
  
  // Channel
  channelId       String
  channel         NotificationChannel @relation(fields: [channelId], references: [id])
  
  // Event
  eventType       String
  eventId         String?
  
  // Delivery
  status          DeliveryStatus
  recipient       String?
  subject         String?
  message         String?  @db.Text
  
  // Result
  deliveredAt     DateTime?
  failureReason   String?  @db.Text
  retryCount      Int      @default(0)
  
  // Metadata
  metadata        Json?
  
  // Timestamp
  createdAt       DateTime @default(now())
  
  @@index([channelId])
  @@index([status])
  @@index([eventType])
  @@index([createdAt])
  @@map("notification_logs")
}

enum DeliveryStatus {
  PENDING
  SENT
  FAILED
  THROTTLED
  DEBOUNCED
}

enum Severity {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

// On-Call Schedule (SRE)
model OnCallSchedule {
  id              String   @id @default(uuid())
  
  // Identity
  name            String
  description     String?  @db.Text
  timezone        String   @default('UTC')
  
  // Schedule
  rotationType    RotationType @default(WEEKLY)
  rotationStart   DateTime
  
  // Team
  teamMembers     String[] // Array of user IDs
  currentOnCall   String?  // Current on-call user ID
  
  // Settings
  isActive        Boolean  @default(true)
  handoffTime     String   @db.VarChar(5) // HH:MM format
  
  // Relations
  escalationPolicies EscalationPolicy[]
  
  // Timestamps
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  @@index([isActive])
  @@index([currentOnCall])
  @@map("on_call_schedules")
}

enum RotationType {
  DAILY
  WEEKLY
  BIWEEKLY
  MONTHLY
}

// Escalation Policy (SRE)
model EscalationPolicy {
  id              String   @id @default(uuid())
  
  // Identity
  name            String
  description     String?  @db.Text
  
  // Schedule Link
  scheduleId      String
  schedule        OnCallSchedule @relation(fields: [scheduleId], references: [id])
  
  // Escalation Levels
  levels          Json     // Array of escalation levels with timeouts
  
  // Settings
  isActive        Boolean  @default(true)
  repeatPolicy    Boolean  @default(false) // Repeat from level 1 if all levels exhausted
  
  // Timestamps
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  @@index([scheduleId])
  @@index([isActive])
  @@map("escalation_policies")
}
```

---

## 5. Core Implementation

### NotificationService
```typescript
@Injectable()
export class NotificationService {
  constructor(
    @InjectQueue('notifications') private queue: Queue,
    private routingService: RoutingService,
    private onCallService: OnCallService,
    private debounceService: DebounceService
  ) {}
  
  async notify(event: NotificationEvent): Promise<void> {
    // 1. Find matching rules
    const rules = await this.routingService.findMatchingRules(event);
    
    if (rules.length === 0) {
      await this.logService.debug('NOTIFICATION', 'NO_RULES_MATCHED', {
        message: 'No notification rules matched event',
        metadata: { eventType: event.type }
      });
      return;
    }
    
    // 2. Check debounce for each rule
    for (const rule of rules) {
      const shouldSend = await this.debounceService.shouldSend(event, rule);
      
      if (!shouldSend) {
        await this.logNotification(rule.channelId, event, DeliveryStatus.DEBOUNCED);
        continue;
      }
      
      // 3. Queue notification job
      await this.queue.add('send-notification', {
        ruleId: rule.id,
        channelId: rule.channelId,
        event
      }, {
        attempts: 3,
        backoff: {
          type: 'exponential',
          delay: 2000
        },
        removeOnComplete: true
      });
    }
  }
}
```

### Channel Adapters
```typescript
// Base adapter interface
interface IChannelAdapter {
  send(payload: NotificationPayload): Promise<DeliveryResult>;
  test(config: any): Promise<boolean>;
}

// Email adapter
@Injectable()
export class EmailAdapter implements IChannelAdapter {
  async send(payload: NotificationPayload): Promise<DeliveryResult> {
    const transporter = nodemailer.createTransporter({
      host: payload.config.host,
      port: payload.config.port,
      secure: payload.config.secure,
      auth: {
        user: payload.config.user,
        pass: payload.config.password
      }
    });
    
    await transporter.sendMail({
      from: payload.config.from,
      to: payload.recipient,
      subject: payload.subject,
      html: payload.message
    });
    
    return { success: true, deliveredAt: new Date() };
  }
}

// Slack adapter
@Injectable()
export class SlackAdapter implements IChannelAdapter {
  async send(payload: NotificationPayload): Promise<DeliveryResult> {
    await axios.post(payload.config.webhookUrl, {
      text: payload.subject,
      blocks: [
        {
          type: 'section',
          text: { type: 'mrkdwn', text: payload.message }
        }
      ],
      attachments: [{
        color: this.getSeverityColor(payload.severity),
        fields: payload.fields
      }]
    });
    
    return { success: true, deliveredAt: new Date() };
  }
}
```

### Routing Engine
```typescript
@Injectable()
export class RoutingService {
  async findMatchingRules(event: NotificationEvent): Promise<NotificationRule[]> {
    const rules = await this.prisma.notificationRule.findMany({
      where: { isEnabled: true },
      include: { channel: true },
      orderBy: { priority: 'asc' }
    });
    
    return rules.filter(rule => this.matchesRule(event, rule));
  }
  
  private matchesRule(event: NotificationEvent, rule: NotificationRule): boolean {
    // Check event type
    if (rule.eventTypes.length && !rule.eventTypes.includes(event.type)) {
      return false;
    }
    
    // Check severity
    if (rule.minSeverity && !this.meetsMinSeverity(event.severity, rule.minSeverity)) {
      return false;
    }
    
    // Check source module
    if (rule.sourceModules.length && !rule.sourceModules.includes(event.sourceModule)) {
      return false;
    }
    
    // Check advanced conditions (JSONB)
    if (rule.conditions && !this.matchesConditions(event, rule.conditions)) {
      return false;
    }
    
    return true;
  }
}
```

### Debounce Service
```typescript
@Injectable()
export class DebounceService {
  private readonly DEBOUNCE_WINDOW = 30000; // 30 seconds
  private readonly COOLDOWN_PERIOD = 3600000; // 1 hour
  
  async shouldSend(event: NotificationEvent, rule: NotificationRule): Promise<boolean> {
    const key = this.getDebounceKey(event, rule);
    
    // Check if in cooldown
    const cooldownKey = `${key}:cooldown`;
    const inCooldown = await this.redis.get(cooldownKey);
    if (inCooldown) return false;
    
    // Check debounce window
    const windowKey = `${key}:window`;
    const count = await this.redis.incr(windowKey);
    
    if (count === 1) {
      // First event in window
      await this.redis.expire(windowKey, Math.ceil(this.DEBOUNCE_WINDOW / 1000));
      return true;
    }
    
    // Multiple events in window - debounce
    if (count <= 5) {
      return false; // Wait for aggregation
    }
    
    // Send aggregated notification
    await this.redis.del(windowKey);
    await this.redis.setex(cooldownKey, Math.ceil(this.COOLDOWN_PERIOD / 1000), '1');
    return true;
  }
  
  private getDebounceKey(event: NotificationEvent, rule: NotificationRule): string {
    return `debounce:${rule.id}:${event.resourceId}:${event.type}`;
  }
}
```

---

## 6. API Specification

```http
# List Channels
GET /api/v1/notifications/channels

# Create Channel
POST /api/v1/notifications/channels
{
  "name": "Ops Team Slack",
  "type": "SLACK",
  "config": {
    "webhookUrl": "https://hooks.slack.com/..."
  }
}

# Test Channel
POST /api/v1/notifications/channels/:id/test

# List Rules
GET /api/v1/notifications/rules

# Create Rule
POST /api/v1/notifications/rules
{
  "name": "Critical Incidents to Slack",
  "priority": 1,
  "eventTypes": ["INCIDENT_CREATED"],
  "minSeverity": "HIGH",
  "channelId": "uuid"
}

# Get Notification History
GET /api/v1/notifications/logs

# Internal: Send Notification
POST /api/v1/notifications/send (Internal only)
```

---

## 7. Security & RBAC

```typescript
const NOTIFICATION_PERMISSIONS = {
  'notifications.channels.read': 'View channels',
  'notifications.channels.manage': 'Manage channels',
  'notifications.rules.read': 'View rules',
  'notifications.rules.manage': 'Manage rules',
  'notifications.logs.read': 'View notification history'
};

const ROLE_PERMISSIONS = {
  SUPER_ADMIN: ['notifications.*'],
  ADMIN: ['notifications.*'],
  MANAGER: ['notifications.channels.read', 'notifications.rules.read', 'notifications.logs.read'],
  NOC: ['notifications.logs.read'],
  HELPDESK: [],
  HR: [],
  FINANCE: []
};
```

---

## 8. Testing Strategy

### Unit Tests (>85%)
- Adapter implementations
- Routing logic
- Debounce calculations
- Template rendering

### Integration Tests
- End-to-end notification flow
- Channel delivery
- Retry logic
- Rate limiting

### E2E Tests
- Create channel via UI
- Configure rules
- Trigger notification
- View history

---

## 9. Performance Requirements

| Operation | Target | Maximum |
|-----------|--------|---------|
| Queue notification | <10ms | 50ms |
| Route evaluation | <50ms | 100ms |
| Email delivery | <2s | 5s |
| Webhook delivery | <1s | 3s |

**Scalability:** 1000+ notifications/minute, 100+ channels, 500+ rules

---

## 10. Success Metrics

- [ ] All channels deliver successfully
- [ ] Debouncing prevents >80% of duplicate alerts
- [ ] Retry logic achieves >99% delivery
- [ ] Rate limiting prevents spam
- [ ] Template rendering works for all channels

---

## 11. Tech Stack Alignment

- [x] NestJS + Prisma + PostgreSQL
- [x] BullMQ for job queue
- [x] Redis for debouncing
- [x] Nodemailer for email
- [x] Axios for webhooks
- [x] Next.js 14 + React Query
- [x] shadcn/ui + Tailwind CSS
- [x] libsodium-wrappers for encryption

---

**Version:** 2.0.0  
**Last Updated:** February 7, 2026  
**Status:** Ready for Implementation  
**Estimated Completion:** 3 weeks from start date
