# Module 5: Automation & Workflow Engine (SRE Runbooks)
## Professional Implementation Plan

**Version:** 3.0.0  
**Status:** Ready for Implementation  
**Dependencies:** Module 1 (Auth), Module 2 (Server Connections), Module 6 (Incident Management)  
**Estimated Duration:** 5 weeks (200 hours)  
**Team Size:** 2-3 developers

---

## ğŸ¯ IMPLEMENTATION DECISIONS (Feb 11, 2026)

**Runbooks (Phase 1):** 5 essential - Restart Service, Disk Cleanup, Health Check, Process Kill, Log Rotation  
**Rollback:** Manual only (automated too dangerous)  
**Versioning:** None (code deployment = version)  
**Rate Limiting:** Per runbook cooldown periods (10 minutes default)  
**Load Target:** 100 concurrent executions  
**Safety:** Block dangerous commands (rm -rf /, dd, mkfs, etc.)  
**SRE Focus:** Runbook automation for incident response and auto-remediation

---

## 1. Executive Summary

### 1.1 Business Value
The Automation & Workflow Engine (SRE Runbooks) is the "intelligent hands" of OpsManager, programmatically resolving incidents through predefined TypeScript-based runbooks. This module eliminates manual intervention for common operational tasks, reducing MTTR (Mean Time To Resolution) by up to 80% and enabling 24/7 autonomous incident response following Site Reliability Engineering best practices.

**Key Business Outcomes:**
- **Automated Incident Resolution:** 70% of common incidents resolved without human intervention
- **Reduced MTTR:** From hours to minutes for standard operational tasks
- **Cost Savings:** Reduce operational overhead by 60% through automation
- **Consistency:** Eliminate human error in routine maintenance tasks
- **Scalability:** Handle 1000+ concurrent runbook executions
- **SRE Excellence:** Automated runbooks for common failure scenarios

### 1.2 Technical Highlights
- **Pure TypeScript Implementation:** No external automation tools (Ansible, n8n, Jenkins)
- **Runbook Pattern Architecture:** Extensible runbook system with type-safe execution
- **Real-time Execution Monitoring:** Live log streaming and progress tracking
- **Safety-First Design:** Multi-layer validation, rate limiting, and rollback capabilities
- **BullMQ Job Queue:** Reliable, distributed task execution with Redis backing
- **Comprehensive Audit Trail:** Every automation action logged for compliance
- **Server-Focused:** Direct server operations via SSH (no asset abstraction)

### 1.3 Core Concepts
- **Runbook:** TypeScript class implementing standardized automation logic (e.g., ServiceRestartRunbook)
- **Execution:** Single run instance of a runbook for a specific incident/server
- **Step:** Atomic action within a runbook (SSH command, API call, validation check)
- **Context:** Shared data structure passed between steps for state management
- **Safety Rails:** Pre-execution validation, rate limiting, and destructive operation protection
- **Auto-Remediation:** Automatic execution triggered by incident detection


---

## 2. Implementation Roadmap

### Sprint 1: Foundation & Core Engine (Week 1-2)
**Goal:** Establish automation framework and execution engine

**Deliverables:**
- [ ] Playbook interface and base classes
- [ ] AutomationService orchestrator with BullMQ integration
- [ ] Execution context and result handling
- [ ] Database schema (AutomationExecution, AutomationLog, AutomationPlaybook)
- [ ] SSH command wrapper with safety checks
- [ ] Basic error handling and retry logic
- [ ] Unit tests for core engine (>85% coverage)

**Technical Tasks:**
```typescript
// Core interfaces
interface IRunbook {
  id: string;
  name: string;
  description: string;
  version: string;
  supportedPlatforms: PlatformType[]; // ['LINUX', 'WINDOWS']
  requiredPermissions: string[];
  
  validate(context: ExecutionContext): Promise<ValidationResult>;
  execute(context: ExecutionContext): Promise<ExecutionResult>;
  rollback(context: ExecutionContext): Promise<void>;
  canExecute(server: Server, user: User): boolean;
}

// Execution engine
class AutomationService {
  async executeRunbook(
    runbookId: string,
    context: ExecutionContext,
    options: ExecutionOptions
  ): Promise<AutomationExecution>;
  
  async cancelExecution(executionId: string): Promise<void>;
  async retryExecution(executionId: string): Promise<void>;
  async getExecutionLogs(executionId: string): Promise<AutomationLog[]>;
}
```

**Success Criteria:**
- Playbook can be instantiated and executed
- Execution logs captured in real-time
- Failed executions properly handled with retry logic
- All unit tests passing

### Sprint 2: Core Playbooks Implementation (Week 2-3)
**Goal:** Implement MVP playbook library

**Deliverables:**
- [ ] ServiceRestartPlaybook (systemctl operations)
- [ ] DiskCleanupPlaybook (safe log rotation)
- [ ] ProcessKillPlaybook (graceful process termination)
- [ ] FileBackupPlaybook (pre-operation backup)
- [ ] HealthCheckPlaybook (service verification)
- [ ] Playbook registry and discovery system
- [ ] Integration tests for each playbook
- [ ] Playbook documentation generator

**Playbook Implementations:**

**1. ServiceRestartRunbook**
```typescript
export class ServiceRestartRunbook extends BaseRunbook {
  id = 'SERVICE_RESTART';
  name = 'Restart System Service';
  version = '1.0.0';
  supportedPlatforms = [PlatformType.LINUX];
  
  async execute(ctx: ExecutionContext): Promise<ExecutionResult> {
    const { serverId, serviceName } = ctx.params;
    
    // Step 1: Pre-check
    await ctx.logStep('Checking service status', async () => {
      const status = await ctx.ssh.exec(serverId, 
        `systemctl is-active ${serviceName}`
      );
      ctx.data.initialStatus = status.stdout.trim();
    });
    
    // Step 2: Create backup point
    await ctx.logStep('Creating service state backup', async () => {
      await ctx.ssh.exec(serverId, 
        `systemctl show ${serviceName} > /tmp/service-backup-${Date.now()}.txt`
      );
    });
    
    // Step 3: Restart
    await ctx.logStep('Restarting service', async () => {
      await ctx.ssh.exec(serverId, 
        `sudo systemctl restart ${serviceName}`,
        { timeout: 30000 }
      );
    });
    
    // Step 4: Verify
    await ctx.logStep('Verifying service health', async () => {
      await ctx.sleep(2000); // Wait for service to stabilize
      const status = await ctx.ssh.exec(serverId, 
        `systemctl is-active ${serviceName}`
      );
      
      if (status.stdout.trim() !== 'active') {
        throw new PlaybookExecutionError(
          `Service failed to start. Status: ${status.stdout}`
        );
      }
    });
    
    return {
      success: true,
      message: `Service ${serviceName} restarted successfully`,
      data: {
        previousStatus: ctx.data.initialStatus,
        currentStatus: 'active',
        restartTime: new Date()
      }
    };
  }
  
  async rollback(ctx: ExecutionContext): Promise<void> {
    // Attempt to restore previous state if restart failed
    const { serverId, serviceName } = ctx.params;
    await ctx.ssh.exec(serverId, `sudo systemctl start ${serviceName}`);
  }
}
```

**2. DiskCleanupRunbook**
```typescript
export class DiskCleanupRunbook extends BaseRunbook {
  id = 'DISK_CLEANUP';
  name = 'Safe Disk Space Cleanup';
  version = '1.0.0';
  supportedPlatforms = [PlatformType.LINUX];
  
  async execute(ctx: ExecutionContext): Promise<ExecutionResult> {
    const { serverId, targetPath = '/var/log', minSizeGB = 1 } = ctx.params;
    
    // Safety check: Prevent root deletion
    if (targetPath === '/' || targetPath === '/root' || targetPath === '/home') {
      throw new PlaybookValidationError('Cannot cleanup protected directories');
    }
    
    // Step 1: Analyze disk usage
    await ctx.logStep('Analyzing disk usage', async () => {
      const usage = await ctx.ssh.exec(serverId, `df -h ${targetPath}`);
      ctx.data.initialUsage = usage.stdout;
    });
    
    // Step 2: Find large log files
    await ctx.logStep('Identifying large log files', async () => {
      const findCmd = `find ${targetPath} -type f -name "*.log" -size +${minSizeGB}G`;
      const result = await ctx.ssh.exec(serverId, findCmd);
      ctx.data.largeFiles = result.stdout.split('\n').filter(Boolean);
      
      if (ctx.data.largeFiles.length === 0) {
        return { success: true, message: 'No large files found' };
      }
    });
    
    // Step 3: Truncate files (safer than delete)
    await ctx.logStep('Truncating large log files', async () => {
      for (const file of ctx.data.largeFiles) {
        await ctx.ssh.exec(serverId, `sudo truncate -s 0 "${file}"`);
      }
    });
    
    // Step 4: Verify space freed
    await ctx.logStep('Verifying disk space', async () => {
      const usage = await ctx.ssh.exec(serverId, `df -h ${targetPath}`);
      ctx.data.finalUsage = usage.stdout;
    });
    
    return {
      success: true,
      message: `Cleaned ${ctx.data.largeFiles.length} log files`,
      data: {
        filesProcessed: ctx.data.largeFiles.length,
        initialUsage: ctx.data.initialUsage,
        finalUsage: ctx.data.finalUsage
      }
    };
  }
}
```

**Success Criteria:**
- All 5 core playbooks implemented and tested
- Each playbook has rollback capability
- Integration tests verify actual SSH execution
- Playbook registry can discover and list all playbooks


### Sprint 3: Safety & Reliability (Week 3-4)
**Goal:** Implement production-grade safety mechanisms

**Deliverables:**
- [ ] Rate limiting per asset/playbook
- [ ] Destructive operation protection (dry-run mode)
- [ ] Concurrent execution management
- [ ] Execution timeout handling
- [ ] Automatic rollback on failure
- [ ] Command sanitization and validation
- [ ] Audit logging integration
- [ ] Performance monitoring

**Safety Features:**

**1. Rate Limiting**
```typescript
class RateLimiter {
  async checkExecutionAllowed(
    playbookId: string,
    assetId: string
  ): Promise<boolean> {
    const key = `automation:ratelimit:${playbookId}:${assetId}`;
    const lastExecution = await redis.get(key);
    
    if (lastExecution) {
      const elapsed = Date.now() - parseInt(lastExecution);
      const cooldown = 10 * 60 * 1000; // 10 minutes
      
      if (elapsed < cooldown) {
        throw new RateLimitError(
          `Playbook can only run once every 10 minutes. Wait ${cooldown - elapsed}ms`
        );
      }
    }
    
    await redis.setex(key, 600, Date.now().toString());
    return true;
  }
}
```

**2. Destructive Operation Protection**
```typescript
class CommandValidator {
  private dangerousPatterns = [
    /rm\s+-rf\s+\//,           // rm -rf /
    /dd\s+if=.*of=\/dev/,      // dd to disk
    /mkfs/,                     // Format filesystem
    /fdisk/,                    // Partition operations
    />\s*\/dev\/sd[a-z]/       // Write to disk device
  ];
  
  validate(command: string): ValidationResult {
    for (const pattern of this.dangerousPatterns) {
      if (pattern.test(command)) {
        return {
          valid: false,
          reason: `Dangerous operation detected: ${pattern}`,
          severity: 'CRITICAL'
        };
      }
    }
    
    return { valid: true };
  }
  
  sanitize(command: string): string {
    // Remove sensitive data from logs
    return command
      .replace(/password[=:]\s*\S+/gi, 'password=***')
      .replace(/token[=:]\s*\S+/gi, 'token=***')
      .replace(/api[-_]?key[=:]\s*\S+/gi, 'api_key=***');
  }
}
```

**3. Automatic Rollback**
```typescript
class ExecutionManager {
  async executeWithRollback(
    playbook: IPlaybook,
    context: ExecutionContext
  ): Promise<ExecutionResult> {
    const checkpoints: Checkpoint[] = [];
    
    try {
      // Execute with checkpoint tracking
      const result = await playbook.execute(context);
      return result;
    } catch (error) {
      // Automatic rollback on failure
      await this.logAudit({
        action: 'AUTOMATION_ROLLBACK_INITIATED',
        severity: 'HIGH',
        executionId: context.executionId,
        reason: error.message
      });
      
      await playbook.rollback(context);
      
      throw new PlaybookExecutionError(
        `Execution failed and rolled back: ${error.message}`
      );
    }
  }
}
```

**Success Criteria:**
- Rate limiting prevents rapid re-execution
- Dangerous commands blocked before execution
- Failed executions automatically rolled back
- All safety violations logged to audit trail

### Sprint 4: Integration & UI (Week 4-5)
**Goal:** Integrate with incident management and build management UI

**Deliverables:**
- [ ] Incident-triggered automation
- [ ] Manual playbook execution API
- [ ] Real-time execution monitoring UI
- [ ] Playbook library management UI
- [ ] Execution history and analytics
- [ ] Playbook scheduling system
- [ ] Notification integration
- [ ] API documentation

**API Endpoints:**

```typescript
// Playbook Management
GET    /api/v1/automation/playbooks
GET    /api/v1/automation/playbooks/:id
POST   /api/v1/automation/playbooks/:id/validate
POST   /api/v1/automation/playbooks/:id/dry-run

// Execution Management
POST   /api/v1/automation/executions
GET    /api/v1/automation/executions
GET    /api/v1/automation/executions/:id
GET    /api/v1/automation/executions/:id/logs
POST   /api/v1/automation/executions/:id/cancel
POST   /api/v1/automation/executions/:id/retry
DELETE /api/v1/automation/executions/:id

// Scheduling
POST   /api/v1/automation/schedules
GET    /api/v1/automation/schedules
PUT    /api/v1/automation/schedules/:id
DELETE /api/v1/automation/schedules/:id

// Analytics
GET    /api/v1/automation/analytics/success-rate
GET    /api/v1/automation/analytics/execution-time
GET    /api/v1/automation/analytics/most-used
```

**Frontend Components:**

**1. Playbook Library Page**
```typescript
// /automation/playbooks
export default function PlaybooksPage() {
  const { data: playbooks } = useQuery({
    queryKey: ['playbooks'],
    queryFn: fetchPlaybooks
  });
  
  return (
    <div className="space-y-6">
      <PageHeader
        title="Automation Playbooks"
        description="Manage and execute automation playbooks"
        action={
          <Button onClick={() => router.push('/automation/playbooks/new')}>
            <Plus className="h-4 w-4 mr-2" />
            Create Playbook
          </Button>
        }
      />
      
      <PlaybookGrid playbooks={playbooks} />
    </div>
  );
}
```

**2. Execution Monitor**
```typescript
// Real-time execution monitoring
export function ExecutionMonitor({ executionId }: Props) {
  const { data: execution } = useQuery({
    queryKey: ['execution', executionId],
    queryFn: () => fetchExecution(executionId),
    refetchInterval: 2000 // Poll every 2 seconds
  });
  
  const { data: logs } = useQuery({
    queryKey: ['execution-logs', executionId],
    queryFn: () => fetchExecutionLogs(executionId),
    refetchInterval: 1000 // Poll every 1 second
  });
  
  return (
    <Card>
      <CardHeader>
        <ExecutionStatus status={execution.status} />
        <ExecutionProgress 
          currentStep={execution.currentStep}
          totalSteps={execution.totalSteps}
        />
      </CardHeader>
      <CardContent>
        <LogViewer logs={logs} streaming={execution.status === 'RUNNING'} />
      </CardContent>
    </Card>
  );
}
```

**Success Criteria:**
- Incidents automatically trigger appropriate playbooks
- Manual execution works from UI
- Real-time log streaming functional
- Execution history searchable and filterable

### Sprint 5: Advanced Features & Polish (Week 5)
**Goal:** Add advanced capabilities and production readiness

**Deliverables:**
- [ ] Playbook chaining (sequential execution)
- [ ] Conditional execution (if-then-else logic)
- [ ] Parallel step execution
- [ ] Custom playbook parameters UI
- [ ] Execution templates
- [ ] Performance optimization
- [ ] Load testing (1000+ concurrent executions)
- [ ] Production deployment guide

**Advanced Features:**

**1. Playbook Chaining**
```typescript
class PlaybookChain {
  async executeChain(
    playbooks: IPlaybook[],
    context: ExecutionContext
  ): Promise<ChainResult> {
    const results: ExecutionResult[] = [];
    
    for (const playbook of playbooks) {
      const result = await this.automationService.executePlaybook(
        playbook.id,
        context
      );
      
      results.push(result);
      
      // Pass output to next playbook
      context.previousResult = result;
      
      // Stop chain on failure
      if (!result.success) {
        break;
      }
    }
    
    return { results, success: results.every(r => r.success) };
  }
}
```

**2. Conditional Execution**
```typescript
class ConditionalPlaybook extends BasePlaybook {
  async execute(ctx: ExecutionContext): Promise<ExecutionResult> {
    // Evaluate condition
    const condition = await this.evaluateCondition(ctx);
    
    if (condition.result) {
      return await this.executeThenBranch(ctx);
    } else {
      return await this.executeElseBranch(ctx);
    }
  }
  
  private async evaluateCondition(ctx: ExecutionContext): Promise<ConditionResult> {
    // Example: Check disk usage threshold
    const usage = await ctx.ssh.exec(ctx.serverId, "df -h / | tail -1 | awk '{print $5}'");
    const percentage = parseInt(usage.stdout);
    
    return {
      result: percentage > 80,
      value: percentage
    };
  }
}
```

**Success Criteria:**
- Playbook chains execute sequentially
- Conditional logic works correctly
- System handles 1000+ concurrent executions
- All performance benchmarks met


---

## 3. Technical Architecture

### 3.1 System Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        Automation Engine                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚   Incident   â”‚â”€â”€â”€â”€â”€â–¶â”‚  Automation  â”‚â”€â”€â”€â”€â”€â–¶â”‚   Playbook   â”‚  â”‚
â”‚  â”‚   Trigger    â”‚      â”‚   Service    â”‚      â”‚   Registry   â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚         â”‚                      â”‚                      â”‚          â”‚
â”‚         â”‚                      â–¼                      â”‚          â”‚
â”‚         â”‚              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚          â”‚
â”‚         â”‚              â”‚   BullMQ     â”‚              â”‚          â”‚
â”‚         â”‚              â”‚  Job Queue   â”‚              â”‚          â”‚
â”‚         â”‚              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚          â”‚
â”‚         â”‚                      â”‚                      â”‚          â”‚
â”‚         â”‚                      â–¼                      â”‚          â”‚
â”‚         â”‚              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚          â”‚
â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚  Execution   â”‚â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚                        â”‚   Engine     â”‚                          â”‚
â”‚                        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                          â”‚
â”‚                               â”‚                                  â”‚
â”‚                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                  â”‚
â”‚                â–¼              â–¼               â–¼                  â”‚
â”‚         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚
â”‚         â”‚    SSH    â”‚  â”‚    API    â”‚  â”‚  Safety   â”‚            â”‚
â”‚         â”‚  Executor â”‚  â”‚  Client   â”‚  â”‚  Validatorâ”‚            â”‚
â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚
â”‚                â”‚              â”‚               â”‚                  â”‚
â”‚                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                  â”‚
â”‚                               â–¼                                  â”‚
â”‚                        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                          â”‚
â”‚                        â”‚  Audit Log   â”‚                          â”‚
â”‚                        â”‚   Service    â”‚                          â”‚
â”‚                        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚                      â”‚                      â”‚
         â–¼                      â–¼                      â–¼
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚  Servers  â”‚         â”‚   Redis   â”‚         â”‚PostgreSQL â”‚
  â”‚ (SSH/API) â”‚         â”‚  (Queue)  â”‚         â”‚   (DB)    â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 3.2 Component Interactions

**Execution Flow:**
1. **Trigger:** Incident created or manual execution requested
2. **Validation:** Check permissions, rate limits, asset compatibility
3. **Queue:** Job added to BullMQ with priority and retry config
4. **Execution:** Worker picks up job and instantiates playbook
5. **Steps:** Playbook executes steps with real-time logging
6. **Result:** Success/failure recorded, incident updated, notifications sent
7. **Audit:** All actions logged for compliance

### 3.3 Data Flow

```
Incident/Manual Trigger
        â”‚
        â–¼
  Validation Layer
  â”œâ”€ Permission Check
  â”œâ”€ Rate Limit Check
  â”œâ”€ Asset Compatibility
  â””â”€ Safety Validation
        â”‚
        â–¼
   BullMQ Job Queue
   â”œâ”€ Priority: HIGH/NORMAL/LOW
   â”œâ”€ Retry: 3 attempts
   â””â”€ Timeout: 5 minutes
        â”‚
        â–¼
  Execution Engine
  â”œâ”€ Load Playbook
  â”œâ”€ Create Context
  â”œâ”€ Execute Steps
  â””â”€ Handle Result
        â”‚
        â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â–¼             â–¼             â–¼
   SSH Commands   API Calls    Validations
        â”‚             â”‚             â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                      â”‚
                      â–¼
              Real-time Logs
                      â”‚
                      â–¼
              Result Processing
              â”œâ”€ Update Incident
              â”œâ”€ Send Notifications
              â””â”€ Record Metrics
                      â”‚
                      â–¼
                Audit Trail
```

### 3.4 Technology Stack Alignment

**Backend:**
- **Framework:** NestJS with dependency injection
- **Job Queue:** BullMQ (Redis-based) for reliable task execution
- **Database:** PostgreSQL with Prisma ORM
- **Caching:** Redis for rate limiting and execution state
- **SSH:** ssh2 library for remote command execution
- **Validation:** class-validator for input validation

**Frontend:**
- **Framework:** Next.js 14 with App Router
- **State Management:** React Query for server state, Zustand for client state
- **UI Components:** shadcn/ui with Tailwind CSS
- **Real-time Updates:** Polling with React Query (2-second intervals)
- **Forms:** React Hook Form with Zod validation

**Security:**
- **Authentication:** JWT with RS256 signing
- **Authorization:** RBAC with permission checks
- **Encryption:** libsodium-wrappers for sensitive data
- **Audit:** Comprehensive logging of all automation actions

---

## 4. Database Schema

### 4.1 Prisma Schema

```prisma
// Runbook Registry
model AutomationRunbook {
  id                  String   @id @default(uuid())
  
  // Identity
  runbookId           String   @unique // e.g., 'SERVICE_RESTART'
  name                String
  description         String   @db.Text
  version             String
  
  // Configuration
  supportedPlatforms  String[] // ['LINUX', 'WINDOWS']
  requiredPermissions String[] // ['automation.execute', 'servers.manage']
  category            String   // 'MAINTENANCE', 'RECOVERY', 'INCIDENT_RESPONSE'
  
  // Metadata
  author              String
  isActive            Boolean  @default(true)
  isDangerous         Boolean  @default(false) // Requires extra confirmation
  
  // Execution Config
  defaultTimeout      Int      @default(300000) // 5 minutes
  maxRetries          Int      @default(3)
  cooldownMinutes     Int      @default(10)
  
  // Relations
  executions          AutomationExecution[]
  schedules           AutomationSchedule[]
  
  // Timestamps
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt
  
  @@index([runbookId])
  @@index([category])
  @@index([isActive])
  @@map("automation_runbooks")
}

// Execution Records
model AutomationExecution {
  id                  String   @id @default(uuid())
  
  // Trigger
  runbookId           String
  runbook             AutomationRunbook @relation(fields: [runbookId], references: [id])
  
  incidentId          String?
  incident            Incident? @relation(fields: [incidentId], references: [id])
  
  serverId            String
  server              Server @relation(fields: [serverId], references: [id])
  
  triggeredBy         String   // 'INCIDENT', 'MANUAL', 'SCHEDULED'
  triggeredByUserId   String?
  triggeredByUser     User? @relation(fields: [triggeredByUserId], references: [id])
  
  // Execution State
  status              ExecutionStatus @default(PENDING)
  currentStep         String?
  totalSteps          Int?
  progress            Int      @default(0) // 0-100
  
  // Parameters
  parameters          Json     // Playbook-specific params
  
  // Timing
  queuedAt            DateTime @default(now())
  startedAt           DateTime?
  finishedAt          DateTime?
  durationMs          Int?
  
  // Result
  success             Boolean?
  resultSummary       String?  @db.Text
  resultData          Json?
  errorMessage        String?  @db.Text
  errorStack          String?  @db.Text
  
  // Safety
  isDryRun            Boolean  @default(false)
  rollbackPerformed   Boolean  @default(false)
  
  // Relations
  logs                AutomationLog[]
  
  // Timestamps
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt
  
  @@index([runbookId])
  @@index([incidentId])
  @@index([serverId])
  @@index([status])
  @@index([triggeredBy])
  @@index([queuedAt])
  @@map("automation_executions")
}

enum ExecutionStatus {
  PENDING      // Queued, waiting for worker
  RUNNING      // Currently executing
  SUCCESS      // Completed successfully
  FAILED       // Failed with error
  CANCELLED    // Manually cancelled
  TIMEOUT      // Exceeded timeout
  ROLLED_BACK  // Failed and rolled back
}

// Execution Logs
model AutomationLog {
  id                  String   @id @default(uuid())
  
  executionId         String
  execution           AutomationExecution @relation(fields: [executionId], references: [id], onDelete: Cascade)
  
  // Step Info
  stepNumber          Int
  stepName            String
  stepType            String   // 'SSH_COMMAND', 'API_CALL', 'VALIDATION', 'SLEEP'
  
  // Command/Action
  command             String?  @db.Text
  sanitizedCommand    String?  @db.Text // Passwords masked
  
  // Output
  stdout              String?  @db.Text
  stderr              String?  @db.Text
  exitCode            Int?
  
  // Status
  status              String   // 'RUNNING', 'SUCCESS', 'FAILED'
  errorMessage        String?  @db.Text
  
  // Timing
  startedAt           DateTime @default(now())
  finishedAt          DateTime?
  durationMs          Int?
  
  @@index([executionId])
  @@index([stepNumber])
  @@map("automation_logs")
}

// Scheduled Executions
model AutomationSchedule {
  id                  String   @id @default(uuid())
  
  // Runbook
  runbookId           String
  runbook             AutomationRunbook @relation(fields: [runbookId], references: [id])
  
  // Target
  serverId            String
  server              Server @relation(fields: [serverId], references: [id])
  
  // Schedule
  name                String
  description         String?  @db.Text
  cronExpression      String   // '0 2 * * *' = Daily at 2 AM
  timezone            String   @default('UTC')
  
  // Configuration
  parameters          Json
  isActive            Boolean  @default(true)
  
  // Metadata
  createdByUserId     String
  createdBy           User @relation(fields: [createdByUserId], references: [id])
  
  lastRunAt           DateTime?
  nextRunAt           DateTime?
  
  // Timestamps
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt
  
  @@index([runbookId])
  @@index([serverId])
  @@index([isActive])
  @@index([nextRunAt])
  @@map("automation_schedules")
}
```


---

## 5. API Specification

### 5.1 Playbook Management

#### List Playbooks
```http
GET /api/v1/automation/playbooks
Authorization: Bearer <token>

Query Parameters:
- category: string (optional) - Filter by category
- assetType: string (optional) - Filter by supported asset type
- isActive: boolean (optional) - Filter by active status
- search: string (optional) - Search by name/description

Response 200:
{
  "playbooks": [
    {
      "id": "uuid",
      "playbookId": "SERVICE_RESTART",
      "name": "Restart System Service",
      "description": "Safely restart a systemd service with health checks",
      "version": "1.0.0",
      "category": "MAINTENANCE",
      "supportedAssetTypes": ["LINUX_SERVER"],
      "requiredPermissions": ["automation.execute", "servers.manage"],
      "isDangerous": false,
      "defaultTimeout": 300000,
      "maxRetries": 3,
      "cooldownMinutes": 10,
      "isActive": true,
      "author": "OpsManager Team",
      "createdAt": "2026-02-07T10:00:00Z",
      "updatedAt": "2026-02-07T10:00:00Z"
    }
  ],
  "total": 15,
  "page": 1,
  "limit": 20
}
```

#### Get Playbook Details
```http
GET /api/v1/automation/playbooks/:id
Authorization: Bearer <token>

Response 200:
{
  "playbook": {
    "id": "uuid",
    "playbookId": "SERVICE_RESTART",
    "name": "Restart System Service",
    "description": "Safely restart a systemd service...",
    "version": "1.0.0",
    "category": "MAINTENANCE",
    "supportedAssetTypes": ["LINUX_SERVER"],
    "requiredPermissions": ["automation.execute"],
    "parameters": [
      {
        "name": "serviceName",
        "type": "string",
        "required": true,
        "description": "Name of the systemd service"
      },
      {
        "name": "gracefulTimeout",
        "type": "number",
        "required": false,
        "default": 30,
        "description": "Seconds to wait for graceful shutdown"
      }
    ],
    "steps": [
      "Check current service status",
      "Create backup point",
      "Restart service",
      "Verify service health"
    ],
    "estimatedDuration": "30-60 seconds",
    "successRate": 98.5,
    "totalExecutions": 1247,
    "recentExecutions": [...]
  }
}
```

#### Validate Playbook Execution
```http
POST /api/v1/automation/playbooks/:id/validate
Authorization: Bearer <token>
Content-Type: application/json

Request Body:
{
  "assetId": "uuid",
  "parameters": {
    "serviceName": "nginx"
  }
}

Response 200:
{
  "valid": true,
  "checks": {
    "assetCompatibility": true,
    "permissions": true,
    "rateLimitOk": true,
    "parametersValid": true,
    "assetReachable": true
  },
  "warnings": [],
  "estimatedDuration": 45000
}

Response 400:
{
  "valid": false,
  "checks": {
    "assetCompatibility": true,
    "permissions": false,
    "rateLimitOk": false,
    "parametersValid": true,
    "assetReachable": true
  },
  "errors": [
    "Missing required permission: automation.execute",
    "Rate limit: Playbook can run again in 8 minutes"
  ]
}
```

### 5.2 Execution Management

#### Create Execution
```http
POST /api/v1/automation/executions
Authorization: Bearer <token>
Content-Type: application/json

Request Body:
{
  "playbookId": "uuid",
  "assetId": "uuid",
  "parameters": {
    "serviceName": "nginx",
    "gracefulTimeout": 30
  },
  "incidentId": "uuid", // optional
  "isDryRun": false,
  "priority": "NORMAL" // HIGH, NORMAL, LOW
}

Response 201:
{
  "execution": {
    "id": "uuid",
    "playbookId": "uuid",
    "assetId": "uuid",
    "status": "PENDING",
    "queuedAt": "2026-02-07T10:00:00Z",
    "estimatedStartTime": "2026-02-07T10:00:05Z"
  }
}

Response 400:
{
  "error": "ValidationError",
  "message": "Rate limit exceeded. Playbook can run again in 8 minutes",
  "code": "RATE_LIMIT_EXCEEDED"
}
```

#### List Executions
```http
GET /api/v1/automation/executions
Authorization: Bearer <token>

Query Parameters:
- playbookId: string (optional)
- assetId: string (optional)
- status: string (optional) - PENDING, RUNNING, SUCCESS, FAILED
- triggeredBy: string (optional) - INCIDENT, MANUAL, SCHEDULED
- startDate: string (optional) - ISO date
- endDate: string (optional) - ISO date
- page: number (default: 1)
- limit: number (default: 20)

Response 200:
{
  "executions": [
    {
      "id": "uuid",
      "playbookId": "uuid",
      "playbookName": "Restart System Service",
      "assetId": "uuid",
      "assetName": "web-server-01",
      "status": "SUCCESS",
      "triggeredBy": "INCIDENT",
      "triggeredByUser": {
        "id": "uuid",
        "name": "John Doe"
      },
      "queuedAt": "2026-02-07T10:00:00Z",
      "startedAt": "2026-02-07T10:00:05Z",
      "finishedAt": "2026-02-07T10:00:47Z",
      "durationMs": 42000,
      "resultSummary": "Service nginx restarted successfully",
      "progress": 100
    }
  ],
  "total": 1247,
  "page": 1,
  "limit": 20
}
```

#### Get Execution Details
```http
GET /api/v1/automation/executions/:id
Authorization: Bearer <token>

Response 200:
{
  "execution": {
    "id": "uuid",
    "playbook": {
      "id": "uuid",
      "name": "Restart System Service",
      "version": "1.0.0"
    },
    "asset": {
      "id": "uuid",
      "name": "web-server-01",
      "type": "LINUX_SERVER"
    },
    "incident": {
      "id": "uuid",
      "title": "Nginx service down"
    },
    "status": "SUCCESS",
    "currentStep": "Verify service health",
    "totalSteps": 4,
    "progress": 100,
    "parameters": {
      "serviceName": "nginx",
      "gracefulTimeout": 30
    },
    "queuedAt": "2026-02-07T10:00:00Z",
    "startedAt": "2026-02-07T10:00:05Z",
    "finishedAt": "2026-02-07T10:00:47Z",
    "durationMs": 42000,
    "resultSummary": "Service nginx restarted successfully",
    "resultData": {
      "previousStatus": "failed",
      "currentStatus": "active",
      "restartTime": "2026-02-07T10:00:35Z"
    },
    "isDryRun": false,
    "rollbackPerformed": false
  }
}
```

#### Get Execution Logs
```http
GET /api/v1/automation/executions/:id/logs
Authorization: Bearer <token>

Query Parameters:
- stepNumber: number (optional) - Filter by step
- status: string (optional) - SUCCESS, FAILED, RUNNING

Response 200:
{
  "logs": [
    {
      "id": "uuid",
      "stepNumber": 1,
      "stepName": "Check current service status",
      "stepType": "SSH_COMMAND",
      "command": "systemctl is-active nginx",
      "stdout": "failed\n",
      "stderr": "",
      "exitCode": 3,
      "status": "SUCCESS",
      "startedAt": "2026-02-07T10:00:05Z",
      "finishedAt": "2026-02-07T10:00:07Z",
      "durationMs": 2000
    },
    {
      "id": "uuid",
      "stepNumber": 2,
      "stepName": "Create backup point",
      "stepType": "SSH_COMMAND",
      "command": "systemctl show nginx > /tmp/service-backup-1707303607000.txt",
      "stdout": "",
      "stderr": "",
      "exitCode": 0,
      "status": "SUCCESS",
      "startedAt": "2026-02-07T10:00:07Z",
      "finishedAt": "2026-02-07T10:00:09Z",
      "durationMs": 2000
    },
    {
      "id": "uuid",
      "stepNumber": 3,
      "stepName": "Restarting service",
      "stepType": "SSH_COMMAND",
      "command": "sudo systemctl restart nginx",
      "stdout": "",
      "stderr": "",
      "exitCode": 0,
      "status": "SUCCESS",
      "startedAt": "2026-02-07T10:00:09Z",
      "finishedAt": "2026-02-07T10:00:35Z",
      "durationMs": 26000
    },
    {
      "id": "uuid",
      "stepNumber": 4,
      "stepName": "Verifying service health",
      "stepType": "SSH_COMMAND",
      "command": "systemctl is-active nginx",
      "stdout": "active\n",
      "stderr": "",
      "exitCode": 0,
      "status": "SUCCESS",
      "startedAt": "2026-02-07T10:00:37Z",
      "finishedAt": "2026-02-07T10:00:47Z",
      "durationMs": 10000
    }
  ],
  "total": 4
}
```

#### Cancel Execution
```http
POST /api/v1/automation/executions/:id/cancel
Authorization: Bearer <token>

Response 200:
{
  "message": "Execution cancelled successfully",
  "execution": {
    "id": "uuid",
    "status": "CANCELLED",
    "cancelledAt": "2026-02-07T10:01:00Z"
  }
}

Response 400:
{
  "error": "InvalidStateError",
  "message": "Cannot cancel execution in SUCCESS state"
}
```

#### Retry Execution
```http
POST /api/v1/automation/executions/:id/retry
Authorization: Bearer <token>

Response 201:
{
  "message": "Execution retry queued",
  "newExecution": {
    "id": "uuid",
    "status": "PENDING",
    "queuedAt": "2026-02-07T10:02:00Z"
  }
}
```

### 5.3 Scheduling

#### Create Schedule
```http
POST /api/v1/automation/schedules
Authorization: Bearer <token>
Content-Type: application/json

Request Body:
{
  "name": "Daily Disk Cleanup",
  "description": "Clean up log files daily at 2 AM",
  "playbookId": "uuid",
  "assetId": "uuid",
  "cronExpression": "0 2 * * *",
  "timezone": "America/New_York",
  "parameters": {
    "targetPath": "/var/log",
    "minSizeGB": 1
  },
  "isActive": true
}

Response 201:
{
  "schedule": {
    "id": "uuid",
    "name": "Daily Disk Cleanup",
    "playbookId": "uuid",
    "assetId": "uuid",
    "cronExpression": "0 2 * * *",
    "timezone": "America/New_York",
    "isActive": true,
    "nextRunAt": "2026-02-08T02:00:00Z",
    "createdAt": "2026-02-07T10:00:00Z"
  }
}
```

### 5.4 Analytics

#### Get Success Rate
```http
GET /api/v1/automation/analytics/success-rate
Authorization: Bearer <token>

Query Parameters:
- playbookId: string (optional)
- startDate: string (optional)
- endDate: string (optional)
- groupBy: string (optional) - day, week, month

Response 200:
{
  "successRate": 98.5,
  "totalExecutions": 1247,
  "successfulExecutions": 1228,
  "failedExecutions": 19,
  "timeline": [
    {
      "date": "2026-02-01",
      "successRate": 97.8,
      "total": 45,
      "successful": 44,
      "failed": 1
    }
  ]
}
```


---

## 6. Security Considerations

### 6.1 Authentication & Authorization

**Permission Requirements:**
```typescript
// Required permissions for automation operations
const AUTOMATION_PERMISSIONS = {
  'automation.playbooks.read': 'View playbook library',
  'automation.playbooks.execute': 'Execute playbooks',
  'automation.playbooks.manage': 'Create/edit playbooks',
  'automation.executions.read': 'View execution history',
  'automation.executions.cancel': 'Cancel running executions',
  'automation.schedules.manage': 'Manage scheduled executions'
};

// Role-based access
const ROLE_PERMISSIONS = {
  SUPER_ADMIN: ['automation.*'],
  ADMIN: ['automation.*'],
  MANAGER: ['automation.playbooks.read', 'automation.playbooks.execute', 'automation.executions.*'],
  NOC: ['automation.playbooks.read', 'automation.playbooks.execute', 'automation.executions.read'],
  HELPDESK: ['automation.playbooks.read', 'automation.executions.read'],
  HR: [], // No automation access
  FINANCE: [] // No automation access
};
```

**Authorization Guards:**
```typescript
@Controller('automation')
@UseGuards(JwtAuthGuard, PermissionGuard)
export class AutomationController {
  @Post('executions')
  @RequirePermissions('automation.playbooks.execute')
  async createExecution(
    @Body() dto: CreateExecutionDto,
    @CurrentUser() user: User
  ): Promise<ExecutionResponse> {
    // Additional validation: Check if user has access to target asset
    await this.validateAssetAccess(user, dto.assetId);
    
    return this.automationService.executePlaybook(dto, user);
  }
}
```

### 6.2 Credential Protection

**SSH Credential Handling:**
```typescript
class SecureSSHExecutor {
  async executeCommand(
    serverId: string,
    command: string,
    context: ExecutionContext
  ): Promise<CommandResult> {
    // 1. Decrypt credentials (in-memory only)
    const credentials = await this.credentialService.getDecrypted(serverId);
    
    try {
      // 2. Execute command
      const result = await this.sshClient.exec(credentials, command);
      
      // 3. Sanitize output before logging
      const sanitized = this.sanitizer.sanitize(result.stdout);
      
      // 4. Log sanitized output
      await context.logStep('Command executed', {
        command: this.sanitizer.sanitizeCommand(command),
        output: sanitized,
        exitCode: result.exitCode
      });
      
      return result;
    } finally {
      // 5. Clear credentials from memory
      credentials.password = null;
      credentials.privateKey = null;
    }
  }
}
```

**Command Sanitization:**
```typescript
class CommandSanitizer {
  private sensitivePatterns = [
    /password[=:]\s*\S+/gi,
    /token[=:]\s*\S+/gi,
    /api[-_]?key[=:]\s*\S+/gi,
    /secret[=:]\s*\S+/gi,
    /-----BEGIN .* KEY-----.*-----END .* KEY-----/gs
  ];
  
  sanitize(text: string): string {
    let sanitized = text;
    
    for (const pattern of this.sensitivePatterns) {
      sanitized = sanitized.replace(pattern, (match) => {
        const key = match.split(/[=:]/)[0];
        return `${key}=***`;
      });
    }
    
    return sanitized;
  }
  
  sanitizeCommand(command: string): string {
    // Remove inline passwords from commands
    return command
      .replace(/--password[=\s]+\S+/gi, '--password=***')
      .replace(/-p\s*\S+/gi, '-p ***');
  }
}
```

### 6.3 Safety Mechanisms

**1. Destructive Operation Protection**
```typescript
class SafetyValidator {
  private dangerousPatterns = [
    { pattern: /rm\s+-rf\s+\/(?!tmp|var\/tmp)/i, severity: 'CRITICAL', message: 'Attempting to delete root filesystem' },
    { pattern: /dd\s+if=.*of=\/dev\/sd[a-z]/i, severity: 'CRITICAL', message: 'Attempting to write to disk device' },
    { pattern: /mkfs/i, severity: 'CRITICAL', message: 'Attempting to format filesystem' },
    { pattern: /fdisk|parted/i, severity: 'HIGH', message: 'Attempting disk partitioning' },
    { pattern: />\s*\/dev\/sd[a-z]/i, severity: 'CRITICAL', message: 'Attempting to write to disk device' },
    { pattern: /chmod\s+777\s+\//i, severity: 'HIGH', message: 'Attempting to set dangerous permissions on root' },
    { pattern: /chown\s+.*\s+\//i, severity: 'HIGH', message: 'Attempting to change ownership of root' }
  ];
  
  async validate(command: string, context: ExecutionContext): Promise<ValidationResult> {
    for (const check of this.dangerousPatterns) {
      if (check.pattern.test(command)) {
        // Log security violation
        await this.auditService.log({
          action: 'AUTOMATION_DANGEROUS_COMMAND_BLOCKED',
          severity: 'CRITICAL',
          userId: context.userId,
          executionId: context.executionId,
          description: `Blocked dangerous command: ${check.message}`,
          metadata: {
            command: this.sanitizer.sanitize(command),
            pattern: check.pattern.toString()
          }
        });
        
        throw new DangerousOperationError(
          `Command blocked: ${check.message}`,
          check.severity
        );
      }
    }
    
    return { valid: true };
  }
}
```

**2. Rate Limiting**
```typescript
class AutomationRateLimiter {
  async checkLimit(
    playbookId: string,
    assetId: string
  ): Promise<RateLimitResult> {
    const key = `automation:ratelimit:${playbookId}:${assetId}`;
    const lastExecution = await this.redis.get(key);
    
    if (lastExecution) {
      const elapsed = Date.now() - parseInt(lastExecution);
      const cooldown = await this.getPlaybookCooldown(playbookId);
      
      if (elapsed < cooldown) {
        const waitTime = cooldown - elapsed;
        
        throw new RateLimitError(
          `Playbook can only run once every ${cooldown / 60000} minutes. ` +
          `Wait ${Math.ceil(waitTime / 1000)} seconds.`,
          waitTime
        );
      }
    }
    
    // Set rate limit
    await this.redis.setex(key, Math.ceil(cooldown / 1000), Date.now().toString());
    
    return { allowed: true };
  }
  
  private async getPlaybookCooldown(playbookId: string): Promise<number> {
    const playbook = await this.prisma.automationPlaybook.findUnique({
      where: { id: playbookId },
      select: { cooldownMinutes: true }
    });
    
    return (playbook?.cooldownMinutes || 10) * 60 * 1000;
  }
}
```

**3. Execution Timeout**
```typescript
class ExecutionTimeoutManager {
  async executeWithTimeout<T>(
    fn: () => Promise<T>,
    timeoutMs: number,
    context: ExecutionContext
  ): Promise<T> {
    return Promise.race([
      fn(),
      new Promise<T>((_, reject) => {
        setTimeout(() => {
          this.auditService.log({
            action: 'AUTOMATION_EXECUTION_TIMEOUT',
            severity: 'WARNING',
            executionId: context.executionId,
            description: `Execution exceeded timeout of ${timeoutMs}ms`
          });
          
          reject(new ExecutionTimeoutError(
            `Execution exceeded timeout of ${timeoutMs}ms`
          ));
        }, timeoutMs);
      })
    ]);
  }
}
```

### 6.4 Audit Logging

**Comprehensive Audit Trail:**
```typescript
class AutomationAuditService {
  async logExecution(
    execution: AutomationExecution,
    action: string,
    result: 'SUCCESS' | 'FAILURE',
    metadata?: any
  ): Promise<void> {
    await this.auditService.log({
      action: `AUTOMATION_${action}`,
      severity: result === 'FAILURE' ? 'WARNING' : 'INFO',
      userId: execution.triggeredByUserId,
      entityType: 'automation_execution',
      entityId: execution.id,
      result,
      description: this.buildDescription(execution, action, result),
      metadata: {
        playbookId: execution.playbookId,
        assetId: execution.assetId,
        incidentId: execution.incidentId,
        durationMs: execution.durationMs,
        ...metadata
      }
    });
  }
  
  private buildDescription(
    execution: AutomationExecution,
    action: string,
    result: string
  ): string {
    const playbook = execution.playbook.name;
    const asset = execution.asset.name;
    
    switch (action) {
      case 'EXECUTION_STARTED':
        return `Started automation: ${playbook} on ${asset}`;
      case 'EXECUTION_COMPLETED':
        return `Completed automation: ${playbook} on ${asset} - ${result}`;
      case 'EXECUTION_CANCELLED':
        return `Cancelled automation: ${playbook} on ${asset}`;
      case 'EXECUTION_ROLLED_BACK':
        return `Rolled back automation: ${playbook} on ${asset}`;
      default:
        return `Automation ${action}: ${playbook} on ${asset}`;
    }
  }
}
```

**Audit Events:**
- `AUTOMATION_EXECUTION_STARTED` - Playbook execution began
- `AUTOMATION_EXECUTION_COMPLETED` - Playbook execution finished
- `AUTOMATION_EXECUTION_FAILED` - Playbook execution failed
- `AUTOMATION_EXECUTION_CANCELLED` - Execution manually cancelled
- `AUTOMATION_EXECUTION_TIMEOUT` - Execution exceeded timeout
- `AUTOMATION_EXECUTION_ROLLED_BACK` - Automatic rollback performed
- `AUTOMATION_DANGEROUS_COMMAND_BLOCKED` - Dangerous command prevented
- `AUTOMATION_RATE_LIMIT_EXCEEDED` - Rate limit triggered
- `AUTOMATION_SCHEDULE_CREATED` - New schedule created
- `AUTOMATION_SCHEDULE_DELETED` - Schedule removed


---

## 7. Testing Strategy

### 7.1 Unit Tests (Target: >85% Coverage)

**Playbook Tests:**
```typescript
describe('ServiceRestartPlaybook', () => {
  let playbook: ServiceRestartPlaybook;
  let mockSSH: jest.Mocked<SSHExecutor>;
  let mockContext: ExecutionContext;
  
  beforeEach(() => {
    mockSSH = createMockSSHExecutor();
    mockContext = createMockExecutionContext({ ssh: mockSSH });
    playbook = new ServiceRestartPlaybook();
  });
  
  describe('execute', () => {
    it('should successfully restart active service', async () => {
      // Arrange
      mockSSH.exec
        .mockResolvedValueOnce({ stdout: 'active', exitCode: 0 }) // Initial status
        .mockResolvedValueOnce({ stdout: '', exitCode: 0 })       // Backup
        .mockResolvedValueOnce({ stdout: '', exitCode: 0 })       // Restart
        .mockResolvedValueOnce({ stdout: 'active', exitCode: 0 }); // Verify
      
      mockContext.params = { serverId: 'server-1', serviceName: 'nginx' };
      
      // Act
      const result = await playbook.execute(mockContext);
      
      // Assert
      expect(result.success).toBe(true);
      expect(result.message).toContain('restarted successfully');
      expect(mockSSH.exec).toHaveBeenCalledTimes(4);
      expect(mockContext.logStep).toHaveBeenCalledTimes(4);
    });
    
    it('should handle failed service restart', async () => {
      // Arrange
      mockSSH.exec
        .mockResolvedValueOnce({ stdout: 'failed', exitCode: 3 })
        .mockResolvedValueOnce({ stdout: '', exitCode: 0 })
        .mockResolvedValueOnce({ stdout: '', exitCode: 0 })
        .mockResolvedValueOnce({ stdout: 'failed', exitCode: 3 });
      
      mockContext.params = { serverId: 'server-1', serviceName: 'nginx' };
      
      // Act & Assert
      await expect(playbook.execute(mockContext)).rejects.toThrow(
        PlaybookExecutionError
      );
    });
    
    it('should perform rollback on failure', async () => {
      // Test rollback logic
    });
  });
  
  describe('validate', () => {
    it('should validate required parameters', async () => {
      mockContext.params = { serverId: 'server-1' }; // Missing serviceName
      
      const result = await playbook.validate(mockContext);
      
      expect(result.valid).toBe(false);
      expect(result.errors).toContain('serviceName is required');
    });
  });
});
```

**Safety Validator Tests:**
```typescript
describe('SafetyValidator', () => {
  let validator: SafetyValidator;
  let mockContext: ExecutionContext;
  
  beforeEach(() => {
    validator = new SafetyValidator();
    mockContext = createMockExecutionContext();
  });
  
  it('should block dangerous rm -rf / command', async () => {
    await expect(
      validator.validate('rm -rf /', mockContext)
    ).rejects.toThrow(DangerousOperationError);
  });
  
  it('should allow safe rm command', async () => {
    const result = await validator.validate('rm -rf /tmp/test', mockContext);
    expect(result.valid).toBe(true);
  });
  
  it('should block dd to disk device', async () => {
    await expect(
      validator.validate('dd if=/dev/zero of=/dev/sda', mockContext)
    ).rejects.toThrow(DangerousOperationError);
  });
  
  it('should block filesystem formatting', async () => {
    await expect(
      validator.validate('mkfs.ext4 /dev/sda1', mockContext)
    ).rejects.toThrow(DangerousOperationError);
  });
});
```

**Rate Limiter Tests:**
```typescript
describe('AutomationRateLimiter', () => {
  let rateLimiter: AutomationRateLimiter;
  let mockRedis: jest.Mocked<Redis>;
  
  beforeEach(() => {
    mockRedis = createMockRedis();
    rateLimiter = new AutomationRateLimiter(mockRedis);
  });
  
  it('should allow first execution', async () => {
    mockRedis.get.mockResolvedValue(null);
    
    const result = await rateLimiter.checkLimit('playbook-1', 'asset-1');
    
    expect(result.allowed).toBe(true);
    expect(mockRedis.setex).toHaveBeenCalled();
  });
  
  it('should block rapid re-execution', async () => {
    const recentExecution = (Date.now() - 60000).toString(); // 1 minute ago
    mockRedis.get.mockResolvedValue(recentExecution);
    
    await expect(
      rateLimiter.checkLimit('playbook-1', 'asset-1')
    ).rejects.toThrow(RateLimitError);
  });
  
  it('should allow execution after cooldown', async () => {
    const oldExecution = (Date.now() - 11 * 60000).toString(); // 11 minutes ago
    mockRedis.get.mockResolvedValue(oldExecution);
    
    const result = await rateLimiter.checkLimit('playbook-1', 'asset-1');
    
    expect(result.allowed).toBe(true);
  });
});
```

### 7.2 Integration Tests

**End-to-End Execution Test:**
```typescript
describe('Automation Integration', () => {
  let app: INestApplication;
  let prisma: PrismaService;
  let redis: Redis;
  
  beforeAll(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule]
    }).compile();
    
    app = moduleRef.createNestApplication();
    await app.init();
    
    prisma = app.get(PrismaService);
    redis = app.get('REDIS_CLIENT');
  });
  
  afterAll(async () => {
    await app.close();
  });
  
  describe('POST /automation/executions', () => {
    it('should execute playbook successfully', async () => {
      // Arrange
      const playbook = await createTestPlaybook(prisma);
      const asset = await createTestAsset(prisma);
      const user = await createTestUser(prisma, { role: 'ADMIN' });
      const token = generateTestToken(user);
      
      // Act
      const response = await request(app.getHttpServer())
        .post('/api/v1/automation/executions')
        .set('Authorization', `Bearer ${token}`)
        .send({
          playbookId: playbook.id,
          assetId: asset.id,
          parameters: { serviceName: 'nginx' }
        })
        .expect(201);
      
      // Assert
      expect(response.body.execution).toHaveProperty('id');
      expect(response.body.execution.status).toBe('PENDING');
      
      // Wait for execution to complete
      await waitForExecution(response.body.execution.id, 30000);
      
      // Verify execution completed
      const execution = await prisma.automationExecution.findUnique({
        where: { id: response.body.execution.id }
      });
      
      expect(execution.status).toBe('SUCCESS');
      expect(execution.resultSummary).toBeTruthy();
      
      // Verify logs were created
      const logs = await prisma.automationLog.findMany({
        where: { executionId: execution.id }
      });
      
      expect(logs.length).toBeGreaterThan(0);
    });
    
    it('should enforce rate limiting', async () => {
      // First execution
      await request(app.getHttpServer())
        .post('/api/v1/automation/executions')
        .set('Authorization', `Bearer ${token}`)
        .send(executionDto)
        .expect(201);
      
      // Immediate second execution should fail
      await request(app.getHttpServer())
        .post('/api/v1/automation/executions')
        .set('Authorization', `Bearer ${token}`)
        .send(executionDto)
        .expect(429);
    });
    
    it('should enforce RBAC permissions', async () => {
      const helpdeskUser = await createTestUser(prisma, { role: 'HELPDESK' });
      const helpdeskToken = generateTestToken(helpdeskUser);
      
      await request(app.getHttpServer())
        .post('/api/v1/automation/executions')
        .set('Authorization', `Bearer ${helpdeskToken}`)
        .send(executionDto)
        .expect(403);
    });
  });
});
```

### 7.3 Load Testing

**Concurrent Execution Test:**
```typescript
describe('Load Testing', () => {
  it('should handle 1000 concurrent executions', async () => {
    const executions = Array.from({ length: 1000 }, (_, i) => ({
      playbookId: 'test-playbook',
      assetId: `asset-${i % 100}`, // 100 unique assets
      parameters: { test: true }
    }));
    
    const startTime = Date.now();
    
    // Execute all concurrently
    const results = await Promise.allSettled(
      executions.map(dto => 
        automationService.executePlaybook(dto, mockUser)
      )
    );
    
    const duration = Date.now() - startTime;
    
    // Assertions
    const successful = results.filter(r => r.status === 'fulfilled').length;
    const failed = results.filter(r => r.status === 'rejected').length;
    
    expect(successful).toBeGreaterThan(950); // >95% success rate
    expect(duration).toBeLessThan(60000); // Complete within 1 minute
    
    console.log(`Load Test Results:
      Total: ${executions.length}
      Successful: ${successful}
      Failed: ${failed}
      Duration: ${duration}ms
      Throughput: ${(executions.length / duration * 1000).toFixed(2)} exec/sec
    `);
  });
});
```

### 7.4 Manual Testing Checklist

**Functional Testing:**
- [ ] Execute ServiceRestartPlaybook on Linux server
- [ ] Execute DiskCleanupPlaybook and verify space freed
- [ ] Cancel running execution mid-flight
- [ ] Retry failed execution
- [ ] View real-time logs during execution
- [ ] Verify rollback on failure
- [ ] Test dry-run mode
- [ ] Create and trigger scheduled execution

**Security Testing:**
- [ ] Verify dangerous commands are blocked
- [ ] Verify rate limiting works
- [ ] Verify RBAC permissions enforced
- [ ] Verify credentials never logged
- [ ] Verify audit trail complete
- [ ] Test with different user roles

**Performance Testing:**
- [ ] Execute 100 playbooks concurrently
- [ ] Verify no memory leaks during long-running executions
- [ ] Test execution timeout handling
- [ ] Verify queue processing under load

**UI Testing:**
- [ ] Playbook library displays correctly
- [ ] Execution monitor shows real-time updates
- [ ] Execution history searchable
- [ ] Schedule creation works
- [ ] Analytics dashboard displays metrics


---

## 8. Performance Requirements

### 8.1 Response Time Targets

| Operation | Target | Maximum |
|-----------|--------|---------|
| List playbooks | <100ms | 200ms |
| Get playbook details | <50ms | 100ms |
| Validate execution | <200ms | 500ms |
| Queue execution | <100ms | 200ms |
| Get execution status | <50ms | 100ms |
| Stream logs (per fetch) | <100ms | 200ms |
| Cancel execution | <500ms | 1000ms |

### 8.2 Throughput Requirements

**Execution Capacity:**
- **Concurrent Executions:** Support 1000+ simultaneous playbook executions
- **Queue Throughput:** Process 100+ jobs per second
- **Log Ingestion:** Handle 10,000+ log entries per second
- **API Requests:** Support 1000+ requests per second

**Scalability:**
```typescript
// BullMQ Worker Configuration
const workerConfig = {
  concurrency: 50, // Process 50 jobs concurrently per worker
  limiter: {
    max: 100, // Max 100 jobs per interval
    duration: 1000 // Per second
  },
  settings: {
    stalledInterval: 30000, // Check for stalled jobs every 30s
    maxStalledCount: 3 // Retry stalled jobs 3 times
  }
};

// Horizontal Scaling
// Deploy multiple worker instances:
// - Worker 1-3: Handle HIGH priority executions
// - Worker 4-10: Handle NORMAL priority executions
// - Worker 11-15: Handle LOW priority executions
```

### 8.3 Resource Optimization

**Caching Strategy:**
```typescript
class AutomationCacheService {
  // Cache playbook metadata (1 hour TTL)
  async getPlaybook(id: string): Promise<AutomationPlaybook> {
    const cacheKey = `playbook:${id}`;
    const cached = await this.redis.get(cacheKey);
    
    if (cached) {
      return JSON.parse(cached);
    }
    
    const playbook = await this.prisma.automationPlaybook.findUnique({
      where: { id }
    });
    
    await this.redis.setex(cacheKey, 3600, JSON.stringify(playbook));
    return playbook;
  }
  
  // Cache execution status (10 second TTL for active executions)
  async getExecutionStatus(id: string): Promise<ExecutionStatus> {
    const cacheKey = `execution:status:${id}`;
    const cached = await this.redis.get(cacheKey);
    
    if (cached) {
      return cached as ExecutionStatus;
    }
    
    const execution = await this.prisma.automationExecution.findUnique({
      where: { id },
      select: { status: true }
    });
    
    const ttl = execution.status === 'RUNNING' ? 10 : 300;
    await this.redis.setex(cacheKey, ttl, execution.status);
    
    return execution.status;
  }
}
```

**Database Optimization:**
```sql
-- Indexes for performance
CREATE INDEX idx_executions_status ON automation_executions(status);
CREATE INDEX idx_executions_queued_at ON automation_executions(queued_at);
CREATE INDEX idx_executions_playbook_asset ON automation_executions(playbook_id, asset_id);
CREATE INDEX idx_logs_execution_step ON automation_logs(execution_id, step_number);

-- Partitioning for large tables (PostgreSQL 12+)
CREATE TABLE automation_logs_2026_02 PARTITION OF automation_logs
  FOR VALUES FROM ('2026-02-01') TO ('2026-03-01');
```

**Connection Pooling:**
```typescript
// Prisma connection pool
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  
  // Connection pool settings
  connection_limit = 100
  pool_timeout = 30
}

// Redis connection pool
const redis = new Redis({
  host: process.env.REDIS_HOST,
  port: parseInt(process.env.REDIS_PORT),
  maxRetriesPerRequest: 3,
  enableReadyCheck: true,
  lazyConnect: false,
  
  // Connection pool
  maxConnections: 50,
  minConnections: 10
});
```

### 8.4 Monitoring & Metrics

**Key Performance Indicators:**
```typescript
class AutomationMetricsService {
  async recordExecution(execution: AutomationExecution): Promise<void> {
    // Record execution metrics
    await this.metricsService.record({
      metric: 'automation.execution.duration',
      value: execution.durationMs,
      tags: {
        playbookId: execution.playbookId,
        status: execution.status,
        assetType: execution.asset.type
      }
    });
    
    await this.metricsService.increment('automation.execution.count', {
      playbookId: execution.playbookId,
      status: execution.status
    });
  }
  
  async getPerformanceMetrics(): Promise<PerformanceMetrics> {
    return {
      avgExecutionTime: await this.getAvgExecutionTime(),
      successRate: await this.getSuccessRate(),
      queueDepth: await this.getQueueDepth(),
      activeExecutions: await this.getActiveExecutions(),
      throughput: await this.getThroughput()
    };
  }
}
```

**Performance Alerts:**
- Execution time > 5 minutes (timeout warning)
- Queue depth > 1000 jobs (capacity warning)
- Success rate < 95% (reliability warning)
- Active executions > 800 (scaling warning)
- Memory usage > 80% (resource warning)

---

## 9. Success Metrics

### 9.1 Functional Metrics

**Automation Coverage:**
- [ ] 5+ core playbooks implemented and tested
- [ ] 100% of playbooks have rollback capability
- [ ] All playbooks support dry-run mode
- [ ] Playbook registry discoverable via API

**Execution Reliability:**
- [ ] >98% execution success rate
- [ ] <1% execution timeout rate
- [ ] 100% of failures trigger rollback
- [ ] 100% of executions logged to audit trail

**Safety Compliance:**
- [ ] 0 dangerous commands executed
- [ ] 100% rate limit enforcement
- [ ] 100% RBAC permission checks
- [ ] 0 credential leaks in logs

### 9.2 Performance Metrics

**Response Times:**
- [ ] API endpoints meet <200ms target
- [ ] Execution queueing <100ms
- [ ] Log streaming <100ms per fetch
- [ ] Real-time UI updates <2s latency

**Scalability:**
- [ ] Support 1000+ concurrent executions
- [ ] Process 100+ jobs per second
- [ ] Handle 10,000+ log entries per second
- [ ] Zero downtime during deployments

### 9.3 Security Metrics

**Access Control:**
- [ ] 100% of operations require authentication
- [ ] 100% of operations enforce RBAC
- [ ] 0 unauthorized access attempts succeed
- [ ] All security events logged

**Audit Compliance:**
- [ ] 100% of executions logged
- [ ] 100% of security events logged
- [ ] Audit logs immutable
- [ ] Audit retention >90 days

### 9.4 User Experience Metrics

**Usability:**
- [ ] Playbook execution <3 clicks
- [ ] Real-time log streaming functional
- [ ] Execution history searchable
- [ ] Schedule creation intuitive

**Documentation:**
- [ ] API documentation complete
- [ ] Playbook development guide published
- [ ] User guide with examples
- [ ] Troubleshooting guide available

---

## 10. Tech Stack Alignment Checklist

### 10.1 Backend Alignment

- [x] **Framework:** NestJS with dependency injection
- [x] **Database:** PostgreSQL with Prisma ORM
- [x] **Job Queue:** BullMQ (Redis-based)
- [x] **Caching:** Redis for rate limiting and state
- [x] **Validation:** class-validator decorators
- [x] **Authentication:** JWT with RS256 signing
- [x] **Authorization:** RBAC with permission guards
- [x] **Encryption:** libsodium-wrappers for credentials
- [x] **Audit:** Comprehensive logging service
- [x] **Error Handling:** Standard HTTP status codes

### 10.2 Frontend Alignment

- [x] **Framework:** Next.js 14 with App Router
- [x] **State Management:** React Query + Zustand
- [x] **UI Components:** shadcn/ui with Tailwind CSS
- [x] **Forms:** React Hook Form with Zod validation
- [x] **Real-time Updates:** Polling with React Query
- [x] **Icons:** Lucide React
- [x] **Styling:** Tailwind CSS utility-first

### 10.3 Integration Alignment

- [x] **Module 1 (Auth):** JWT authentication, RBAC permissions
- [x] **Module 2 (Servers):** SSH executor, credential decryption
- [x] **Module 3 (Integration Hub):** API client for external services
- [x] **Module 4 (Asset Registry):** Asset lookup and validation
- [x] **Module 6 (Incidents):** Incident-triggered automation

### 10.4 Security Alignment

- [x] **Password Hashing:** Argon2id (not applicable for automation)
- [x] **Credential Storage:** libsodium-wrappers encryption
- [x] **RBAC:** 6-role hierarchy enforced
- [x] **Audit Logging:** Immutable audit events
- [x] **Input Validation:** class-validator on all inputs
- [x] **Error Handling:** No stack traces to client
- [x] **Testing:** Manual verification after implementation

---

## 11. Documentation Deliverables

### 11.1 Technical Documentation

**Architecture Documentation:**
- System architecture diagrams
- Component interaction flows
- Data flow diagrams
- Database schema documentation
- API reference documentation

**Developer Documentation:**
- Playbook development guide
- Custom playbook creation tutorial
- Testing guide for playbooks
- Deployment guide
- Troubleshooting guide

### 11.2 User Documentation

**User Guides:**
- Automation overview and concepts
- Playbook library guide
- Execution monitoring guide
- Schedule management guide
- Best practices guide

**API Documentation:**
- OpenAPI/Swagger specification
- Authentication guide
- Rate limiting documentation
- Error code reference
- Example requests/responses

### 11.3 Operational Documentation

**Operations Guides:**
- Deployment procedures
- Monitoring and alerting setup
- Performance tuning guide
- Backup and recovery procedures
- Incident response playbook

**Maintenance Documentation:**
- Database maintenance procedures
- Log rotation and archival
- Performance optimization guide
- Scaling guide
- Upgrade procedures

---

## 12. Implementation Notes

### 12.1 Development Best Practices

**Code Organization:**
```
src/automation/
â”œâ”€â”€ playbooks/              # Playbook implementations
â”‚   â”œâ”€â”€ base/
â”‚   â”‚   â”œâ”€â”€ base-playbook.ts
â”‚   â”‚   â””â”€â”€ playbook.interface.ts
â”‚   â”œâ”€â”€ maintenance/
â”‚   â”‚   â”œâ”€â”€ service-restart.playbook.ts
â”‚   â”‚   â”œâ”€â”€ disk-cleanup.playbook.ts
â”‚   â”‚   â””â”€â”€ process-kill.playbook.ts
â”‚   â””â”€â”€ recovery/
â”‚       â”œâ”€â”€ file-backup.playbook.ts
â”‚       â””â”€â”€ health-check.playbook.ts
â”œâ”€â”€ services/
â”‚   â”œâ”€â”€ automation.service.ts
â”‚   â”œâ”€â”€ execution.service.ts
â”‚   â”œâ”€â”€ playbook-registry.service.ts
â”‚   â”œâ”€â”€ safety-validator.service.ts
â”‚   â””â”€â”€ rate-limiter.service.ts
â”œâ”€â”€ executors/
â”‚   â”œâ”€â”€ ssh-executor.service.ts
â”‚   â”œâ”€â”€ api-executor.service.ts
â”‚   â””â”€â”€ command-sanitizer.service.ts
â”œâ”€â”€ controllers/
â”‚   â”œâ”€â”€ automation.controller.ts
â”‚   â”œâ”€â”€ execution.controller.ts
â”‚   â””â”€â”€ schedule.controller.ts
â”œâ”€â”€ dto/
â”‚   â”œâ”€â”€ create-execution.dto.ts
â”‚   â”œâ”€â”€ create-schedule.dto.ts
â”‚   â””â”€â”€ playbook-params.dto.ts
â””â”€â”€ workers/
    â””â”€â”€ automation.worker.ts
```

**Error Handling Pattern:**
```typescript
// Custom error hierarchy
export class AutomationError extends Error {
  constructor(message: string, public code: string) {
    super(message);
    this.name = 'AutomationError';
  }
}

export class PlaybookExecutionError extends AutomationError {
  constructor(message: string) {
    super(message, 'PLAYBOOK_EXECUTION_ERROR');
  }
}

export class DangerousOperationError extends AutomationError {
  constructor(message: string, public severity: string) {
    super(message, 'DANGEROUS_OPERATION');
  }
}

export class RateLimitError extends AutomationError {
  constructor(message: string, public retryAfter: number) {
    super(message, 'RATE_LIMIT_EXCEEDED');
  }
}
```

### 12.2 Deployment Considerations

**Environment Variables:**
```bash
# Automation Configuration
AUTOMATION_WORKER_CONCURRENCY=50
AUTOMATION_MAX_EXECUTION_TIME=300000
AUTOMATION_DEFAULT_COOLDOWN=600000

# BullMQ Configuration
REDIS_HOST=localhost
REDIS_PORT=6379
BULLMQ_QUEUE_NAME=automation-executions

# Safety Configuration
AUTOMATION_ENABLE_DANGEROUS_COMMANDS=false
AUTOMATION_DRY_RUN_DEFAULT=false
```

**Production Checklist:**
- [ ] Environment variables configured
- [ ] Database migrations applied
- [ ] Redis cluster configured
- [ ] BullMQ workers deployed
- [ ] Monitoring and alerting configured
- [ ] Log aggregation setup
- [ ] Backup procedures tested
- [ ] Disaster recovery plan documented

---

**Version:** 2.0.0  
**Last Updated:** February 7, 2026  
**Status:** Ready for Implementation  
**Estimated Completion:** 5 weeks from start date

