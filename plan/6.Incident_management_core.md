# Module 6: Incident Management Core (SRE-Focused)
## Professional Implementation Plan

**Version:** 3.0.0  
**Status:** Ready for Implementation  
**Dependencies:** Module 1 (Auth), Module 2 (Servers), Module 5 (Automation), Module 7 (Logging), Module 8 (Notifications)  
**Estimated Duration:** 4 weeks (160 hours)  
**Team Size:** 2-3 developers

---

## ğŸ¯ IMPLEMENTATION DECISIONS (Feb 11, 2026)

**Deduplication Window:** 15 minutes (industry standard flap detection)  
**State Machine:** 6 states with strict transitions  
**Circuit Breaker:** Automatic escalation after max retries  
**Soft Delete:** 90-day purge policy  
**Real-time Updates:** Server-Sent Events (SSE) with polling fallback (<100ms latency)  
**SRE Focus:** SLO/SLI tracking, error budgets, postmortems, on-call integration  
**Event Emission:** All state changes emit SSE events for real-time UI updates

---

## 1. Executive Summary

### 1.1 Business Value
The Incident Management Core is the "central nervous system" of OpsManager, providing a standardized, immutable record of every operational issue from detection to resolution. This module orchestrates the entire incident lifecycle with a strong focus on Site Reliability Engineering (SRE) principles, enabling teams to track, manage, and resolve issues efficiently while maintaining comprehensive audit trails and learning from failures through blameless postmortems.

**Key Business Outcomes:**
- **Reduced MTTR:** Decrease Mean Time To Resolution by 60% through automated workflows
- **Improved Visibility:** Real-time incident tracking with comprehensive timeline views
- **SLO Compliance:** Automated SLO/SLI tracking ensuring 99.9% service reliability
- **Error Budget Management:** Track and manage error budgets to inform deployment decisions
- **Audit Trail:** Complete immutable history for compliance and root cause analysis
- **Deduplication:** Prevent alert fatigue by intelligently grouping related incidents
- **Blameless Culture:** Postmortem templates promoting learning over blame

### 1.2 Technical Highlights
- **State Machine Architecture:** Strict status transitions with validation and audit logging
- **Intelligent Deduplication:** Fingerprint-based incident grouping to prevent alert spam
- **Circuit Breaker Pattern:** Automatic escalation after failed automation attempts
- **Real-time Timeline:** Append-only event log with SSE live updates (<100ms latency)
- **SSE Event Emission:** All state changes broadcast to connected clients in real-time
- **SLO/SLI Tracking:** Service Level Objective and Indicator monitoring
- **Error Budget Calculation:** Automated error budget tracking and alerting
- **Postmortem Templates:** Structured incident analysis for continuous improvement
- **On-Call Integration:** Automatic routing to on-call engineers
- **Integration Hub:** Seamless integration with monitoring, automation, and notification modules

### 1.3 Core Concepts
- **Incident:** Container for operational issues with lifecycle management
- **State Machine:** Strict rules governing status transitions (NEW â†’ INVESTIGATING â†’ RESOLVED)
- **Timeline:** Immutable append-only log of all incident events
- **Fingerprint:** Unique hash for deduplication (MD5 of serverId + errorType)
- **Circuit Breaker:** Automatic escalation after max retry attempts exceeded
- **SLO (Service Level Objective):** Target reliability metric (e.g., 99.9% uptime)
- **SLI (Service Level Indicator):** Actual measured reliability
- **Error Budget:** Allowed failure rate before impacting SLO
- **Postmortem:** Blameless incident analysis document


---

## 2. Implementation Roadmap

### Sprint 1: Core Infrastructure & State Machine (Week 1)
**Goal:** Establish incident data model and state machine foundation

**Deliverables:**
- [ ] Database schema (Incident, IncidentEvent, IncidentAssignment)
- [ ] State machine implementation with transition validation
- [ ] IncidentService with CRUD operations
- [ ] Deduplication logic using fingerprints
- [ ] Event logging service
- [ ] Unit tests for state machine (>85% coverage)

**Technical Tasks:**
```typescript
// State machine implementation
class IncidentStateMachine {
  constructor(
    private prisma: PrismaService,
    private auditService: AuditService,
    private eventBus: EventBusService // NEW: SSE event emission
  ) {}

  private transitions: Map<IncidentStatus, IncidentStatus[]> = new Map([
    [IncidentStatus.NEW, [
      IncidentStatus.INVESTIGATING,
      IncidentStatus.RESOLVED,
      IncidentStatus.WONT_FIX
    ]],
    [IncidentStatus.INVESTIGATING, [
      IncidentStatus.FIX_IN_PROGRESS,
      IncidentStatus.RESOLVED,
      IncidentStatus.ESCALATED,
      IncidentStatus.WONT_FIX
    ]],
    [IncidentStatus.FIX_IN_PROGRESS, [
      IncidentStatus.INVESTIGATING,
      IncidentStatus.MONITORING,
      IncidentStatus.ESCALATED
    ]],
    [IncidentStatus.MONITORING, [
      IncidentStatus.RESOLVED,
      IncidentStatus.INVESTIGATING
    ]],
    [IncidentStatus.RESOLVED, [
      IncidentStatus.CLOSED
    ]],
    [IncidentStatus.ESCALATED, [
      IncidentStatus.INVESTIGATING,
      IncidentStatus.WONT_FIX
    ]]
  ]);
  
  canTransition(from: IncidentStatus, to: IncidentStatus): boolean {
    const allowedTransitions = this.transitions.get(from) || [];
    return allowedTransitions.includes(to);
  }
  
  async transition(
    incidentId: string,
    toStatus: IncidentStatus,
    userId: string,
    reason?: string
  ): Promise<Incident> {
    const incident = await this.prisma.incident.findUnique({
      where: { id: incidentId }
    });
    
    if (!this.canTransition(incident.status, toStatus)) {
      throw new InvalidTransitionError(
        `Cannot transition from ${incident.status} to ${toStatus}`
      );
    }
    
    // Update incident and log event in transaction
    const updated = await this.prisma.$transaction(async (tx) => {
      const updated = await tx.incident.update({
        where: { id: incidentId },
        data: {
          status: toStatus,
          resolvedAt: toStatus === IncidentStatus.RESOLVED ? new Date() : undefined
        }
      });
      
      await tx.incidentEvent.create({
        data: {
          incidentId,
          type: EventType.STATUS_CHANGE,
          message: `Status changed from ${incident.status} to ${toStatus}`,
          metadata: { reason, previousStatus: incident.status },
          actorId: userId
        }
      });
      
      // Log audit event
      await this.auditService.log({
        action: 'INCIDENT_STATUS_CHANGED',
        severity: 'INFO',
        userId,
        entityType: 'incident',
        entityId: incidentId,
        result: 'SUCCESS',
        metadata: { from: incident.status, to: toStatus }
      });
      
      return updated;
    });

    // NEW: Emit SSE event for real-time UI updates
    this.eventBus.emit({
      type: SystemEvent.INCIDENT_STATUS_CHANGED,
      data: {
        id: incidentId,
        status: toStatus,
        previousStatus: incident.status,
        incident: updated
      },
      timestamp: new Date(),
      permissions: ['incidents.read']
    });
    
    return updated;
  }
}
```

**Deduplication Logic:**
```typescript
class IncidentDeduplicationService {
  generateFingerprint(assetId: string, errorType: string, metadata?: any): string {
    const data = `${assetId}:${errorType}:${JSON.stringify(metadata || {})}`;
    return crypto.createHash('md5').update(data).digest('hex');
  }
  
  async createOrUpdate(dto: CreateIncidentDto): Promise<Incident> {
    const fingerprint = this.generateFingerprint(
      dto.assetId,
      dto.errorType,
      dto.metadata
    );
    
    // Check for existing open incident with same fingerprint
    const existing = await this.prisma.incident.findFirst({
      where: {
        fingerprint,
        status: {
          notIn: [IncidentStatus.RESOLVED, IncidentStatus.CLOSED, IncidentStatus.WONT_FIX]
        }
      }
    });
    
    if (existing) {
      // Update existing incident
      return await this.prisma.$transaction(async (tx) => {
        const updated = await tx.incident.update({
          where: { id: existing.id },
          data: {
            lastSeenAt: new Date(),
            occurrenceCount: { increment: 1 }
          }
        });
        
        await tx.incidentEvent.create({
          data: {
            incidentId: existing.id,
            type: EventType.RECURRENCE,
            message: 'Incident recurred',
            metadata: { newData: dto }
          }
        });
        
        return updated;
      });
    }
    
    // Create new incident
    return await this.createIncident(dto, fingerprint);
  }
}
```

**Success Criteria:**
- State machine validates all transitions correctly
- Deduplication prevents duplicate incidents
- All state changes logged to timeline
- Unit tests achieve >85% coverage


### Sprint 2: Circuit Breaker & SLA Tracking (Week 2)
**Goal:** Implement retry limits and automated escalation

**Deliverables:**
- [ ] Circuit breaker implementation
- [ ] Attempt tracking and limits
- [ ] SLA tracking service
- [ ] Automated severity escalation
- [ ] Background job for SLA monitoring
- [ ] Integration tests for circuit breaker

**Circuit Breaker Implementation:**
```typescript
class IncidentCircuitBreakerService {
  async incrementAttempts(incidentId: string): Promise<Incident> {
    const incident = await this.prisma.incident.findUnique({
      where: { id: incidentId }
    });
    
    const newAttempts = incident.currentAttempts + 1;
    
    // Check if max attempts exceeded
    if (newAttempts >= incident.maxAttempts) {
      return await this.escalateIncident(incident, 'Max automation attempts exceeded');
    }
    
    return await this.prisma.incident.update({
      where: { id: incidentId },
      data: { currentAttempts: newAttempts }
    });
  }
  
  private async escalateIncident(
    incident: Incident,
    reason: string
  ): Promise<Incident> {
    return await this.prisma.$transaction(async (tx) => {
      const updated = await tx.incident.update({
        where: { id: incident.id },
        data: {
          status: IncidentStatus.ESCALATED,
          severity: this.upgradeSeverity(incident.severity),
          currentAttempts: incident.currentAttempts + 1
        }
      });
      
      await tx.incidentEvent.create({
        data: {
          incidentId: incident.id,
          type: EventType.ESCALATION,
          message: `Incident escalated: ${reason}`,
          metadata: {
            reason,
            attempts: incident.currentAttempts + 1,
            maxAttempts: incident.maxAttempts,
            previousSeverity: incident.severity,
            newSeverity: updated.severity
          }
        }
      });
      
      // Trigger notification
      await this.notificationService.sendEscalationAlert(updated);
      
      return updated;
    });
  }
  
  private upgradeSeverity(current: Severity): Severity {
    const hierarchy = [Severity.LOW, Severity.MEDIUM, Severity.HIGH, Severity.CRITICAL];
    const currentIndex = hierarchy.indexOf(current);
    return hierarchy[Math.min(currentIndex + 1, hierarchy.length - 1)];
  }
}
```

**SLA Tracking Service:**
```typescript
class IncidentSLAService {
  private slaThresholds = {
    [Severity.CRITICAL]: { response: 15 * 60 * 1000, resolution: 4 * 60 * 60 * 1000 }, // 15min, 4h
    [Severity.HIGH]: { response: 1 * 60 * 60 * 1000, resolution: 8 * 60 * 60 * 1000 },  // 1h, 8h
    [Severity.MEDIUM]: { response: 4 * 60 * 60 * 1000, resolution: 24 * 60 * 60 * 1000 }, // 4h, 24h
    [Severity.LOW]: { response: 24 * 60 * 60 * 1000, resolution: 72 * 60 * 60 * 1000 }  // 24h, 72h
  };
  
  async checkSLACompliance(incidentId: string): Promise<SLAStatus> {
    const incident = await this.prisma.incident.findUnique({
      where: { id: incidentId },
      include: { events: true }
    });
    
    const thresholds = this.slaThresholds[incident.severity];
    const now = Date.now();
    const createdAt = incident.createdAt.getTime();
    const age = now - createdAt;
    
    // Check response SLA
    const firstResponse = incident.events.find(e => 
      e.type === EventType.STATUS_CHANGE && 
      e.metadata?.to === IncidentStatus.INVESTIGATING
    );
    
    const responseTime = firstResponse 
      ? firstResponse.createdAt.getTime() - createdAt
      : age;
    
    const responseSLAMet = responseTime <= thresholds.response;
    
    // Check resolution SLA
    const resolutionTime = incident.resolvedAt
      ? incident.resolvedAt.getTime() - createdAt
      : age;
    
    const resolutionSLAMet = incident.resolvedAt
      ? resolutionTime <= thresholds.resolution
      : age <= thresholds.resolution;
    
    return {
      responseSLAMet,
      resolutionSLAMet,
      responseTime,
      resolutionTime,
      responseThreshold: thresholds.response,
      resolutionThreshold: thresholds.resolution,
      percentageElapsed: (age / thresholds.resolution) * 100
    };
  }
  
  async escalateOverdueSLAs(): Promise<void> {
    const openIncidents = await this.prisma.incident.findMany({
      where: {
        status: {
          notIn: [IncidentStatus.RESOLVED, IncidentStatus.CLOSED, IncidentStatus.WONT_FIX]
        }
      }
    });
    
    for (const incident of openIncidents) {
      const sla = await this.checkSLACompliance(incident.id);
      
      // Escalate if resolution SLA breached
      if (!sla.resolutionSLAMet && sla.percentageElapsed > 100) {
        await this.circuitBreakerService.escalateIncident(
          incident,
          `Resolution SLA breached (${Math.round(sla.percentageElapsed)}% elapsed)`
        );
      }
      
      // Upgrade severity if approaching SLA breach
      if (sla.percentageElapsed > 80 && sla.percentageElapsed <= 100) {
        await this.upgradeSeverityForSLA(incident);
      }
    }
  }
}
```

**Background Job (BullMQ):**
```typescript
@Processor('incident-sla-monitoring')
export class IncidentSLAProcessor {
  constructor(private slaService: IncidentSLAService) {}
  
  @Process('check-sla-compliance')
  async handleSLACheck(job: Job): Promise<void> {
    await this.slaService.escalateOverdueSLAs();
  }
}

// Schedule job every 5 minutes
@Injectable()
export class IncidentSLAScheduler {
  constructor(
    @InjectQueue('incident-sla-monitoring') private queue: Queue
  ) {}
  
  @Cron('*/5 * * * *') // Every 5 minutes
  async scheduleSLACheck(): Promise<void> {
    await this.queue.add('check-sla-compliance', {}, {
      removeOnComplete: true,
      removeOnFail: false
    });
  }
}
```

**Success Criteria:**
- Circuit breaker escalates after max attempts
- SLA tracking calculates compliance correctly
- Background job runs every 5 minutes
- Overdue incidents automatically escalated

### Sprint 3: API & Integration (Week 3)
**Goal:** Build REST API and integrate with other modules

**Deliverables:**
- [ ] Complete REST API (15+ endpoints)
- [ ] Integration with Module 4 (Asset Registry)
- [ ] Integration with Module 5 (Automation)
- [ ] Integration with Module 8 (Notifications)
- [ ] API documentation (OpenAPI/Swagger)
- [ ] Integration tests for all endpoints

**API Endpoints:**

```typescript
@Controller('incidents')
@UseGuards(JwtAuthGuard, PermissionGuard)
export class IncidentController {
  @Post()
  @RequirePermissions('incidents.create')
  async createIncident(
    @Body() dto: CreateIncidentDto,
    @CurrentUser() user: User
  ): Promise<IncidentResponse> {
    return this.incidentService.createOrUpdate(dto, user);
  }
  
  @Get()
  @RequirePermissions('incidents.read')
  async listIncidents(
    @Query() query: ListIncidentsDto
  ): Promise<PaginatedResponse<Incident>> {
    return this.incidentService.list(query);
  }
  
  @Get(':id')
  @RequirePermissions('incidents.read')
  async getIncident(
    @Param('id') id: string
  ): Promise<IncidentDetailResponse> {
    return this.incidentService.getWithTimeline(id);
  }
  
  @Patch(':id/status')
  @RequirePermissions('incidents.update')
  async updateStatus(
    @Param('id') id: string,
    @Body() dto: UpdateStatusDto,
    @CurrentUser() user: User
  ): Promise<Incident> {
    return this.stateMachine.transition(id, dto.status, user.id, dto.reason);
  }
  
  @Post(':id/events')
  @RequirePermissions('incidents.update')
  async addEvent(
    @Param('id') id: string,
    @Body() dto: AddEventDto,
    @CurrentUser() user: User
  ): Promise<IncidentEvent> {
    return this.incidentService.addEvent(id, dto, user.id);
  }
  
  @Post(':id/resolve')
  @RequirePermissions('incidents.resolve')
  async resolveIncident(
    @Param('id') id: string,
    @Body() dto: ResolveIncidentDto,
    @CurrentUser() user: User
  ): Promise<Incident> {
    return this.incidentService.resolve(id, dto, user.id);
  }
  
  @Post(':id/assign')
  @RequirePermissions('incidents.assign')
  async assignIncident(
    @Param('id') id: string,
    @Body() dto: AssignIncidentDto,
    @CurrentUser() user: User
  ): Promise<Incident> {
    return this.incidentService.assign(id, dto.assigneeId, user.id);
  }
  
  @Get('stats/overview')
  @RequirePermissions('incidents.read')
  async getStats(): Promise<IncidentStats> {
    return this.incidentService.getStats();
  }
  
  @Get('stats/mttr')
  @RequirePermissions('incidents.read')
  async getMTTR(
    @Query() query: MTTRQueryDto
  ): Promise<MTTRStats> {
    return this.incidentService.calculateMTTR(query);
  }
}
```

**Integration with Automation Module:**
```typescript
// Called by automation module when playbook starts
async onAutomationStarted(
  incidentId: string,
  playbookId: string,
  executionId: string
): Promise<void> {
  await this.stateMachine.transition(
    incidentId,
    IncidentStatus.FIX_IN_PROGRESS,
    'SYSTEM',
    `Automation playbook ${playbookId} started`
  );
  
  await this.incidentService.addEvent(incidentId, {
    type: EventType.AUTOMATION_TRIGGERED,
    message: `Automation playbook started: ${playbookId}`,
    metadata: { playbookId, executionId }
  }, null);
}

// Called by automation module when playbook completes
async onAutomationCompleted(
  incidentId: string,
  executionId: string,
  success: boolean,
  result: any
): Promise<void> {
  if (success) {
    await this.stateMachine.transition(
      incidentId,
      IncidentStatus.MONITORING,
      'SYSTEM',
      'Automation completed successfully'
    );
  } else {
    await this.circuitBreakerService.incrementAttempts(incidentId);
    
    await this.incidentService.addEvent(incidentId, {
      type: EventType.AUTOMATION_RESULT,
      message: 'Automation failed',
      metadata: { executionId, result }
    }, null);
  }
}
```

**Success Criteria:**
- All API endpoints functional and documented
- Integration with automation module working
- Notifications sent on status changes
- API tests achieve >80% coverage


### Sprint 4: Frontend & Polish (Week 4)
**Goal:** Build incident management UI and production readiness

**Deliverables:**
- [ ] Incident list page with filtering
- [ ] Incident detail page with timeline
- [ ] Kanban board view
- [ ] Real-time updates with polling
- [ ] Incident creation form
- [ ] Dashboard widgets
- [ ] E2E tests for critical flows
- [ ] Production deployment guide

**Frontend Components:**

**1. Incident List Page**
```typescript
// /incidents
export default function IncidentsPage() {
  const [filters, setFilters] = useState<IncidentFilters>({
    status: [],
    severity: [],
    assetId: null
  });
  
  const { data, isLoading } = useQuery({
    queryKey: ['incidents', filters],
    queryFn: () => fetchIncidents(filters),
    refetchInterval: 30000 // Poll every 30 seconds
  });
  
  return (
    <div className="space-y-6">
      <PageHeader
        title="Incidents"
        description="Manage and track operational incidents"
        action={
          <Button onClick={() => router.push('/incidents/new')}>
            <Plus className="h-4 w-4 mr-2" />
            Create Incident
          </Button>
        }
      />
      
      <IncidentFilters filters={filters} onChange={setFilters} />
      
      <IncidentTable incidents={data?.incidents} loading={isLoading} />
    </div>
  );
}
```

**2. Incident Detail Page with Timeline**
```typescript
// /incidents/[id]
export default function IncidentDetailPage({ params }: Props) {
  const { data: incident } = useQuery({
    queryKey: ['incident', params.id],
    queryFn: () => fetchIncident(params.id),
    refetchInterval: 5000 // Poll every 5 seconds for real-time updates
  });
  
  const { data: events } = useQuery({
    queryKey: ['incident-events', params.id],
    queryFn: () => fetchIncidentEvents(params.id),
    refetchInterval: 2000 // Poll every 2 seconds
  });
  
  return (
    <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
      {/* Left Column: Incident Details */}
      <div className="lg:col-span-2 space-y-6">
        <IncidentHeader incident={incident} />
        
        <Card>
          <CardHeader>
            <CardTitle>Timeline</CardTitle>
          </CardHeader>
          <CardContent>
            <IncidentTimeline events={events} />
          </CardContent>
        </Card>
        
        <Card>
          <CardHeader>
            <CardTitle>Add Comment</CardTitle>
          </CardHeader>
          <CardContent>
            <CommentForm incidentId={params.id} />
          </CardContent>
        </Card>
      </div>
      
      {/* Right Column: Metadata & Actions */}
      <div className="space-y-6">
        <IncidentMetadata incident={incident} />
        <IncidentActions incident={incident} />
        <SLATracker incident={incident} />
      </div>
    </div>
  );
}
```

**3. Kanban Board View**
```typescript
// /incidents/board
export default function IncidentBoardPage() {
  const { data: incidents } = useQuery({
    queryKey: ['incidents', 'all'],
    queryFn: fetchAllIncidents,
    refetchInterval: 10000
  });
  
  const columns = [
    { status: IncidentStatus.NEW, title: 'New', color: 'gray' },
    { status: IncidentStatus.INVESTIGATING, title: 'Investigating', color: 'blue' },
    { status: IncidentStatus.FIX_IN_PROGRESS, title: 'In Progress', color: 'yellow' },
    { status: IncidentStatus.MONITORING, title: 'Monitoring', color: 'purple' },
    { status: IncidentStatus.RESOLVED, title: 'Resolved', color: 'green' }
  ];
  
  return (
    <div className="space-y-6">
      <PageHeader title="Incident Board" description="Kanban view of all incidents" />
      
      <div className="grid grid-cols-5 gap-4">
        {columns.map(column => (
          <KanbanColumn
            key={column.status}
            title={column.title}
            color={column.color}
            incidents={incidents?.filter(i => i.status === column.status)}
          />
        ))}
      </div>
    </div>
  );
}
```

**4. Real-time Timeline Component**
```typescript
export function IncidentTimeline({ events }: Props) {
  return (
    <div className="space-y-4">
      {events?.map((event, index) => (
        <div key={event.id} className="flex gap-4">
          {/* Timeline connector */}
          <div className="flex flex-col items-center">
            <EventIcon type={event.type} />
            {index < events.length - 1 && (
              <div className="w-0.5 h-full bg-border mt-2" />
            )}
          </div>
          
          {/* Event content */}
          <div className="flex-1 pb-8">
            <div className="flex items-center justify-between mb-1">
              <span className="font-medium">{event.message}</span>
              <span className="text-sm text-muted-foreground">
                {formatDistanceToNow(event.createdAt, { addSuffix: true })}
              </span>
            </div>
            
            {event.actorId && (
              <div className="text-sm text-muted-foreground mb-2">
                by {event.actor.name}
              </div>
            )}
            
            {event.metadata && (
              <EventMetadata data={event.metadata} type={event.type} />
            )}
          </div>
        </div>
      ))}
    </div>
  );
}
```

**5. SLA Tracker Widget**
```typescript
export function SLATracker({ incident }: Props) {
  const { data: sla } = useQuery({
    queryKey: ['incident-sla', incident.id],
    queryFn: () => fetchIncidentSLA(incident.id),
    refetchInterval: 60000 // Update every minute
  });
  
  const getProgressColor = (percentage: number) => {
    if (percentage < 50) return 'bg-green-500';
    if (percentage < 80) return 'bg-yellow-500';
    return 'bg-red-500';
  };
  
  return (
    <Card>
      <CardHeader>
        <CardTitle>SLA Tracking</CardTitle>
      </CardHeader>
      <CardContent className="space-y-4">
        {/* Response SLA */}
        <div>
          <div className="flex justify-between mb-2">
            <span className="text-sm font-medium">Response Time</span>
            <span className="text-sm">
              {formatDuration(sla?.responseTime)} / {formatDuration(sla?.responseThreshold)}
            </span>
          </div>
          <Progress 
            value={Math.min((sla?.responseTime / sla?.responseThreshold) * 100, 100)}
            className={getProgressColor((sla?.responseTime / sla?.responseThreshold) * 100)}
          />
          {sla?.responseSLAMet ? (
            <Badge variant="success" className="mt-2">Met</Badge>
          ) : (
            <Badge variant="destructive" className="mt-2">Breached</Badge>
          )}
        </div>
        
        {/* Resolution SLA */}
        <div>
          <div className="flex justify-between mb-2">
            <span className="text-sm font-medium">Resolution Time</span>
            <span className="text-sm">
              {formatDuration(sla?.resolutionTime)} / {formatDuration(sla?.resolutionThreshold)}
            </span>
          </div>
          <Progress 
            value={Math.min(sla?.percentageElapsed, 100)}
            className={getProgressColor(sla?.percentageElapsed)}
          />
          <div className="flex justify-between mt-2">
            <span className="text-sm text-muted-foreground">
              {Math.round(sla?.percentageElapsed)}% elapsed
            </span>
            {sla?.resolutionSLAMet ? (
              <Badge variant="success">On Track</Badge>
            ) : (
              <Badge variant="destructive">At Risk</Badge>
            )}
          </div>
        </div>
      </CardContent>
    </Card>
  );
}
```

**Success Criteria:**
- Incident list page displays and filters correctly
- Timeline updates in real-time (2-5 second polling)
- Kanban board functional with drag-and-drop
- SLA tracker shows accurate progress
- All E2E tests passing

---

## 3. Technical Architecture

### 3.1 System Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Incident Management Core                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  Monitoring  â”‚â”€â”€â”€â”€â”€â–¶â”‚   Incident   â”‚â—€â”€â”€â”€â”€â”€â”‚    Manual    â”‚  â”‚
â”‚  â”‚   Module     â”‚      â”‚   Service    â”‚      â”‚   Creation   â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚         â”‚                      â”‚                      â”‚          â”‚
â”‚         â”‚                      â–¼                      â”‚          â”‚
â”‚         â”‚              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚          â”‚
â”‚         â”‚              â”‚ Deduplicationâ”‚              â”‚          â”‚
â”‚         â”‚              â”‚   Service    â”‚              â”‚          â”‚
â”‚         â”‚              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚          â”‚
â”‚         â”‚                      â”‚                      â”‚          â”‚
â”‚         â”‚                      â–¼                      â”‚          â”‚
â”‚         â”‚              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚          â”‚
â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¶â”‚     State    â”‚â—€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚                        â”‚   Machine    â”‚                          â”‚
â”‚                        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                          â”‚
â”‚                               â”‚                                  â”‚
â”‚                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                  â”‚
â”‚                â–¼              â–¼               â–¼                  â”‚
â”‚         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚
â”‚         â”‚  Circuit  â”‚  â”‚    SLA    â”‚  â”‚  Timeline â”‚            â”‚
â”‚         â”‚  Breaker  â”‚  â”‚  Tracker  â”‚  â”‚  Service  â”‚            â”‚
â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜            â”‚
â”‚                â”‚              â”‚               â”‚                  â”‚
â”‚                â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                  â”‚
â”‚                               â–¼                                  â”‚
â”‚                        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                          â”‚
â”‚                        â”‚  Automation  â”‚                          â”‚
â”‚                        â”‚  Integration â”‚                          â”‚
â”‚                        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                          â”‚
â”‚                               â”‚                                  â”‚
â”‚                               â–¼                                  â”‚
â”‚                        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                          â”‚
â”‚                        â”‚Notification  â”‚                          â”‚
â”‚                        â”‚  Service     â”‚                          â”‚
â”‚                        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚                      â”‚                      â”‚
         â–¼                      â–¼                      â–¼
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚PostgreSQL â”‚         â”‚   Redis   â”‚         â”‚  BullMQ   â”‚
  â”‚   (DB)    â”‚         â”‚  (Cache)  â”‚         â”‚  (Jobs)   â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 3.2 State Machine Flow

```
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚   NEW   â”‚
                    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
                         â”‚
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚              â”‚               â”‚
          â–¼              â–¼               â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ RESOLVED â”‚  â”‚INVESTIGATING â”‚  â”‚WONT_FIX  â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         â”‚
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚              â”‚               â”‚
          â–¼              â–¼               â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ESCALATED â”‚  â”‚FIX_IN_PROGRESSâ”‚ â”‚ RESOLVED â”‚
    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
         â”‚               â”‚               â”‚
         â”‚        â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”        â”‚
         â”‚        â”‚             â”‚        â”‚
         â”‚        â–¼             â–¼        â”‚
         â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
         â””â”€â–¶â”‚INVESTIGATINGâ”‚ â”‚MONITORINGâ”‚  â”‚
            â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜  â”‚
                               â”‚        â”‚
                               â–¼        â”‚
                          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
                          â”‚ RESOLVED â”‚â—€â”€â”˜
                          â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
                               â”‚
                               â–¼
                          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                          â”‚  CLOSED  â”‚
                          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```


---

## 4. Database Schema

### 4.1 Prisma Schema

```prisma
// Incident Model
model Incident {
  id              String   @id @default(uuid())
  friendlyId      Int      @unique @default(autoincrement())
  
  // Identity
  title           String
  description     String?  @db.Text
  fingerprint     String   @db.VarChar(32) // MD5 hash
  
  // Classification
  severity        Severity @default(MEDIUM)
  priority        Priority @default(P3)
  category        String?  @db.VarChar(50)
  
  // Server Link (changed from Asset)
  serverId        String
  server          Server   @relation(fields: [serverId], references: [id])
  
  // State Management
  status          IncidentStatus @default(NEW)
  currentAttempts Int      @default(0)
  maxAttempts     Int      @default(3)
  
  // Assignment
  assigneeId      String?
  assignee        User?    @relation("IncidentAssignee", fields: [assigneeId], references: [id])
  
  // SRE Metrics
  sloImpact       Boolean  @default(false) // Does this impact SLO?
  errorBudgetUsed Float?   // Percentage of error budget consumed
  
  // Metadata
  source          IncidentSource
  occurrenceCount Int      @default(1)
  
  // Timestamps
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  firstSeenAt     DateTime @default(now())
  lastSeenAt      DateTime @default(now())
  acknowledgedAt  DateTime?
  resolvedAt      DateTime?
  closedAt        DateTime?
  
  // Relations
  events          IncidentEvent[]
  postmortem      Postmortem?
  
  @@index([fingerprint])
  @@index([status])
  @@index([severity])
  @@index([serverId])
  @@index([assigneeId])
  @@index([createdAt])
  @@index([sloImpact])
  @@map("incidents")
}

enum IncidentStatus {
  NEW
  INVESTIGATING
  FIX_IN_PROGRESS
  MONITORING
  RESOLVED
  CLOSED
  ESCALATED
  WONT_FIX
}

enum Severity {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

enum Priority {
  P1  // Critical - Immediate action
  P2  // High - Same day
  P3  // Medium - This week
  P4  // Low - This month
}

enum IncidentSource {
  AUTOMATED_MONITOR
  MANUAL_REPORT
  WEBHOOK
  API
  EMAIL
}

// Incident Event (Timeline)
model IncidentEvent {
  id          String   @id @default(uuid())
  
  incidentId  String
  incident    Incident @relation(fields: [incidentId], references: [id], onDelete: Cascade)
  
  // Event Details
  type        EventType
  message     String   @db.Text
  metadata    Json?
  
  // Actor
  actorId     String?  // NULL = System
  actor       User?    @relation(fields: [actorId], references: [id])
  
  // Timestamp
  createdAt   DateTime @default(now())
  
  @@index([incidentId])
  @@index([type])
  @@index([createdAt])
  @@map("incident_events")
}

enum EventType {
  STATUS_CHANGE
  SEVERITY_CHANGE
  ASSIGNMENT
  COMMENT
  AUTOMATION_TRIGGERED
  AUTOMATION_RESULT
  ESCALATION
  RECURRENCE
  SLA_WARNING
  SLA_BREACH
  NOTIFICATION_SENT
  SYSTEM_NOTE
}

// Postmortem Model (SRE)
model Postmortem {
  id              String   @id @default(uuid())
  
  // Incident Link
  incidentId      String   @unique
  incident        Incident @relation(fields: [incidentId], references: [id], onDelete: Cascade)
  
  // Summary
  title           String
  summary         String   @db.Text
  impactSummary   String   @db.Text
  
  // Analysis
  rootCause       String   @db.Text
  contributingFactors String[] // Array of factors
  
  // Timeline
  detectionTime   DateTime
  responseTime    DateTime
  resolutionTime  DateTime
  timelineEvents  Json     // Detailed timeline reconstruction
  
  // Lessons & Actions
  whatWentWell    String   @db.Text
  whatWentWrong   String   @db.Text
  lessonsLearned  String   @db.Text
  actionItems     Json     // Array of action items with owners and due dates
  
  // Metadata
  severity        Severity
  affectedServices String[]
  affectedUsers   Int?
  downtime        Int?     // Minutes of downtime
  
  // Authorship
  createdBy       String
  author          User     @relation(fields: [createdBy], references: [id])
  reviewedBy      String?
  reviewer        User?    @relation("PostmortemReviewer", fields: [reviewedBy], references: [id])
  
  // Status
  status          PostmortemStatus @default(DRAFT)
  publishedAt     DateTime?
  
  // Timestamps
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  @@index([incidentId])
  @@index([status])
  @@index([createdAt])
  @@map("postmortems")
}

enum PostmortemStatus {
  DRAFT
  IN_REVIEW
  PUBLISHED
}
```

---

## 5. API Specification

### 5.1 Core Endpoints

```http
# Create Incident
POST /api/v1/incidents
Authorization: Bearer <token>
Content-Type: application/json

{
  "title": "Website down - HTTP 502",
  "description": "Main website returning 502 Bad Gateway",
  "assetId": "uuid",
  "severity": "HIGH",
  "priority": "P1",
  "source": "AUTOMATED_MONITOR",
  "errorType": "HTTP_502",
  "metadata": {
    "url": "https://example.com",
    "statusCode": 502,
    "responseTime": 5000
  }
}

Response 201:
{
  "incident": {
    "id": "uuid",
    "friendlyId": 1024,
    "title": "Website down - HTTP 502",
    "severity": "HIGH",
    "status": "NEW",
    "fingerprint": "a1b2c3d4e5f6...",
    "createdAt": "2026-02-07T10:00:00Z"
  }
}

# List Incidents
GET /api/v1/incidents?status=NEW,INVESTIGATING&severity=HIGH,CRITICAL&page=1&limit=20

Response 200:
{
  "incidents": [...],
  "total": 45,
  "page": 1,
  "limit": 20
}

# Get Incident with Timeline
GET /api/v1/incidents/:id

Response 200:
{
  "incident": {...},
  "events": [...],
  "sla": {...},
  "relatedIncidents": [...]
}

# Update Status
PATCH /api/v1/incidents/:id/status

{
  "status": "INVESTIGATING",
  "reason": "Starting investigation"
}

# Add Comment
POST /api/v1/incidents/:id/events

{
  "type": "COMMENT",
  "message": "Checked logs, found database connection timeout"
}

# Resolve Incident
POST /api/v1/incidents/:id/resolve

{
  "resolution": "Restarted database service, connections restored",
  "rootCause": "Database connection pool exhausted"
}

# Get Statistics
GET /api/v1/incidents/stats/overview

Response 200:
{
  "total": 1247,
  "open": 23,
  "resolved": 1224,
  "mttr": 1800000, // 30 minutes in ms
  "bySeverity": {
    "CRITICAL": 2,
    "HIGH": 8,
    "MEDIUM": 10,
    "LOW": 3
  },
  "byStatus": {...}
}
```

---

## 6. Security Considerations

### 6.1 RBAC Permissions

```typescript
const INCIDENT_PERMISSIONS = {
  'incidents.read': 'View incidents',
  'incidents.create': 'Create incidents',
  'incidents.update': 'Update incident details',
  'incidents.resolve': 'Resolve incidents',
  'incidents.assign': 'Assign incidents to users',
  'incidents.delete': 'Delete incidents (soft delete)',
  'incidents.escalate': 'Manually escalate incidents'
};

const ROLE_PERMISSIONS = {
  SUPER_ADMIN: ['incidents.*'],
  ADMIN: ['incidents.*'],
  MANAGER: ['incidents.*'],
  NOC: ['incidents.read', 'incidents.create', 'incidents.update', 'incidents.resolve'],
  HELPDESK: ['incidents.read', 'incidents.create'],
  HR: [], // No incident access
  FINANCE: [] // No incident access
};
```

### 6.2 Audit Logging

All incident operations logged:
- `INCIDENT_CREATED` - New incident created
- `INCIDENT_STATUS_CHANGED` - Status transition
- `INCIDENT_SEVERITY_CHANGED` - Severity upgraded/downgraded
- `INCIDENT_ASSIGNED` - Incident assigned to user
- `INCIDENT_RESOLVED` - Incident marked as resolved
- `INCIDENT_ESCALATED` - Automatic or manual escalation
- `INCIDENT_COMMENT_ADDED` - User comment added

---

## 7. Testing Strategy

### 7.1 Unit Tests (>85% Coverage)

- State machine transition validation
- Deduplication logic
- Circuit breaker behavior
- SLA calculation accuracy
- Fingerprint generation

### 7.2 Integration Tests

- End-to-end incident lifecycle
- Automation module integration
- Notification triggers
- Background job execution

### 7.3 E2E Tests

- Create incident via UI
- Update status and add comments
- Resolve incident workflow
- Kanban board interactions

---

## 8. Performance Requirements

| Operation | Target | Maximum |
|-----------|--------|---------|
| Create incident | <100ms | 200ms |
| List incidents | <150ms | 300ms |
| Get incident detail | <100ms | 200ms |
| Update status | <150ms | 300ms |
| Timeline query | <100ms | 200ms |

**Scalability:**
- Support 10,000+ active incidents
- Handle 1000+ incident creations per hour
- Process 100+ status updates per minute

---

## 9. Success Metrics

### 9.1 Functional Metrics
- [ ] Deduplication prevents >95% of duplicate incidents
- [ ] State machine enforces 100% valid transitions
- [ ] Circuit breaker escalates after max attempts
- [ ] SLA tracking accuracy >99%
- [ ] Timeline events captured in real-time

### 9.2 Performance Metrics
- [ ] API response times meet targets
- [ ] Background jobs run on schedule
- [ ] Real-time updates <5 second latency
- [ ] Database queries optimized with indexes

### 9.3 Business Metrics
- [ ] MTTR reduced by 60%
- [ ] SLA compliance >99%
- [ ] Incident resolution rate >95%
- [ ] User satisfaction >4.5/5

---

## 10. Tech Stack Alignment Checklist

- [x] **Backend:** NestJS + Prisma + PostgreSQL
- [x] **Job Queue:** BullMQ for SLA monitoring
- [x] **Caching:** Redis for deduplication checks
- [x] **Frontend:** Next.js 14 + React Query + Zustand
- [x] **UI:** shadcn/ui + Tailwind CSS
- [x] **Validation:** class-validator decorators
- [x] **Auth:** JWT with RS256, RBAC enforcement
- [x] **Audit:** Comprehensive logging
- [x] **Integration:** Modules 1, 4, 5, 7, 8

---

## 11. Documentation Deliverables

- Technical architecture documentation
- API reference (OpenAPI/Swagger)
- State machine diagram
- User guide for incident management
- Developer guide for integrations
- Troubleshooting guide
- Deployment procedures

---

**Version:** 2.0.0  
**Last Updated:** February 7, 2026  
**Status:** Ready for Implementation  
**Estimated Completion:** 4 weeks from start date

