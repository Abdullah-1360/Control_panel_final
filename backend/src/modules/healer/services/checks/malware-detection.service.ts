import { Injectable, Logger } from '@nestjs/common';
import { SshExecutorService } from '../ssh-executor.service';
import {
  IDiagnosisCheckService,
  CheckResult,
  CheckStatus,
  CheckPriority,
  CheckContext,
} from '../../interfaces/diagnosis-check.interface';
import { DiagnosisCheckType } from '../../enums/diagnosis-profile.enum';

/**
 * Malware Detection Service
 * Scans for suspicious files, backdoors, and malicious code
 */
@Injectable()
export class MalwareDetectionService implements IDiagnosisCheckService {
  private readonly logger = new Logger(MalwareDetectionService.name);

  // Known malware signatures and patterns
  private readonly MALWARE_SIGNATURES = [
    'eval(base64_decode',
    'eval(gzinflate',
    'eval(str_rot13',
    'assert(base64_decode',
    'preg_replace.*\/e',
    'system(',
    'exec(',
    'shell_exec(',
    'passthru(',
    'base64_decode.*eval',
    'FilesMan', // Common backdoor
    'c99shell', // C99 shell
    'r57shell', // R57 shell
    'WSO', // WSO shell
    'b374k', // b374k shell
    'Indoxploit', // Indoxploit shell
    'goto', // Obfuscation technique
    '\\x', // Hex encoding (common in malware)
  ];

  // Suspicious file patterns
  private readonly SUSPICIOUS_PATTERNS = [
    '*.suspected',
    '*.bak.php',
    '*.php.bak',
    '*-backup.php',
    'wp-config.php.bak',
    '.htaccess.bak',
    '*.php.*',
    'wp-content/uploads/*.php',
    'wp-includes/*.php.suspected',
  ];

  // Suspicious file names
  private readonly SUSPICIOUS_FILENAMES = [
    'wp-admin.php',
    'wp-content.php',
    'wp-includes.php',
    'wp-config-sample.php.bak',
    'error_log.php',
    'php.ini.php',
    '.htaccess.php',
    'index.php.bak',
    'wp-login.php.bak',
  ];

  constructor(private readonly sshExecutor: SshExecutorService) {}

  async check(
    serverId: string,
    sitePath: string,
    domain: string,
    config?: any,
  ): Promise<CheckResult> {
    const startTime = Date.now();
    const issues: string[] = [];
    const recommendations: string[] = [];
    let score = 100;

    try {
      this.logger.log(`Starting malware scan for ${domain}`);

      // 1. Scan for suspicious files
      const suspiciousFiles = await this.scanSuspiciousFiles(serverId, sitePath);
      if (suspiciousFiles.length > 0) {
        issues.push(`Found ${suspiciousFiles.length} suspicious files`);
        score -= Math.min(50, suspiciousFiles.length * 10);
        recommendations.push('Review and remove suspicious files');
        recommendations.push('Run full malware scan with security plugin');
      }

      // 2. Check for malware signatures in PHP files
      const malwareMatches = await this.scanMalwareSignatures(serverId, sitePath);
      if (malwareMatches.length > 0) {
        issues.push(`Found ${malwareMatches.length} files with malware signatures`);
        score -= Math.min(40, malwareMatches.length * 15);
        recommendations.push('Quarantine infected files immediately');
        recommendations.push('Restore from clean backup');
        recommendations.push('Change all passwords');
      }

      // 3. Check for unauthorized admin users
      const suspiciousAdmins = await this.checkSuspiciousAdmins(serverId, sitePath);
      if (suspiciousAdmins.length > 0) {
        issues.push(`Found ${suspiciousAdmins.length} suspicious admin users`);
        score -= Math.min(30, suspiciousAdmins.length * 10);
        recommendations.push('Review and remove unauthorized admin accounts');
      }

      // 4. Check for suspicious cron jobs
      const suspiciousCrons = await this.checkSuspiciousCrons(serverId, sitePath);
      if (suspiciousCrons.length > 0) {
        issues.push(`Found ${suspiciousCrons.length} suspicious cron jobs`);
        score -= Math.min(20, suspiciousCrons.length * 10);
        recommendations.push('Review and remove suspicious cron jobs');
      }

      // 5. Check for modified core files
      const modifiedCoreFiles = await this.checkModifiedCoreFiles(serverId, sitePath);
      if (modifiedCoreFiles.length > 0) {
        issues.push(`Found ${modifiedCoreFiles.length} modified core files`);
        score -= Math.min(30, modifiedCoreFiles.length * 5);
        recommendations.push('Restore WordPress core files');
      }

      // Determine status
      let status: CheckStatus;
      if (score >= 90) {
        status = CheckStatus.PASS;
      } else if (score >= 70) {
        status = CheckStatus.WARNING;
      } else {
        status = CheckStatus.FAIL;
      }

      const message =
        issues.length === 0
          ? 'No malware or suspicious files detected'
          : `Security issues detected: ${issues.join(', ')}`;

      return {
        checkType: this.getCheckType(),
        status,
        score: Math.max(0, score),
        message,
        details: {
          suspiciousFiles,
          malwareMatches,
          suspiciousAdmins,
          suspiciousCrons,
          modifiedCoreFiles,
          issues,
        },
        recommendations,
        duration: Date.now() - startTime,
        timestamp: new Date(),
      };
    } catch (error) {
      const err = error as Error;
      this.logger.error(`Malware scan failed: ${err.message}`);

      return {
        checkType: this.getCheckType(),
        status: CheckStatus.ERROR,
        score: 0,
        message: `Malware scan failed: ${err.message}`,
        details: { error: err.message },
        recommendations: ['Retry malware scan', 'Check server connectivity'],
        duration: Date.now() - startTime,
        timestamp: new Date(),
      };
    }
  }

  /**
   * Scan for suspicious files
   */
  private async scanSuspiciousFiles(
    serverId: string,
    sitePath: string,
  ): Promise<string[]> {
    try {
      // Find files matching suspicious patterns
      const patterns = this.SUSPICIOUS_PATTERNS.join(' -o -name ');
      const command = `find ${sitePath} -type f \\( -name ${patterns} \\) 2>/dev/null | head -50`;

      const result = await this.sshExecutor.executeCommand(serverId, command, 30000);
      return result
        .split('\n')
        .filter((line) => line.trim() !== '')
        .map((line) => line.trim());
    } catch (error) {
      this.logger.warn(`Failed to scan suspicious files: ${(error as Error).message}`);
      return [];
    }
  }

  /**
   * Scan for malware signatures in PHP files
   */
  private async scanMalwareSignatures(
    serverId: string,
    sitePath: string,
  ): Promise<string[]> {
    try {
      // Search for malware signatures in PHP files
      const signatures = this.MALWARE_SIGNATURES.map((sig) => `-e "${sig}"`).join(' ');
      const command = `grep -r -l ${signatures} ${sitePath}/*.php ${sitePath}/wp-content/*.php ${sitePath}/wp-includes/*.php 2>/dev/null | head -20`;

      const result = await this.sshExecutor.executeCommand(serverId, command, 60000);
      return result
        .split('\n')
        .filter((line) => line.trim() !== '')
        .map((line) => line.trim());
    } catch (error) {
      // grep returns exit code 1 when no matches found
      return [];
    }
  }

  /**
   * Check for suspicious admin users
   */
  private async checkSuspiciousAdmins(
    serverId: string,
    sitePath: string,
  ): Promise<any[]> {
    try {
      // Get list of admin users
      const command = `cd ${sitePath} && wp user list --role=administrator --format=json --allow-root 2>/dev/null || echo "[]"`;

      const result = await this.sshExecutor.executeCommand(serverId, command, 30000);
      const admins = JSON.parse(result || '[]');

      // Flag admins with suspicious characteristics
      return admins.filter((admin: any) => {
        // Suspicious if created recently and has generic name
        const suspiciousNames = ['admin', 'administrator', 'root', 'test', 'user'];
        return suspiciousNames.some((name) =>
          admin.user_login?.toLowerCase().includes(name),
        );
      });
    } catch (error) {
      this.logger.warn(`Failed to check admin users: ${(error as Error).message}`);
      return [];
    }
  }

  /**
   * Check for suspicious cron jobs
   */
  private async checkSuspiciousCrons(
    serverId: string,
    sitePath: string,
  ): Promise<any[]> {
    try {
      // Get WordPress cron jobs
      const command = `cd ${sitePath} && wp cron event list --format=json --allow-root 2>/dev/null || echo "[]"`;

      const result = await this.sshExecutor.executeCommand(serverId, command, 30000);
      const crons = JSON.parse(result || '[]');

      // Flag suspicious cron jobs
      return crons.filter((cron: any) => {
        // Suspicious if hook name contains common malware patterns
        const suspiciousHooks = ['eval', 'base64', 'exec', 'shell', 'system'];
        return suspiciousHooks.some((hook) =>
          cron.hook?.toLowerCase().includes(hook),
        );
      });
    } catch (error) {
      this.logger.warn(`Failed to check cron jobs: ${(error as Error).message}`);
      return [];
    }
  }

  /**
   * Check for modified WordPress core files
   */
  private async checkModifiedCoreFiles(
    serverId: string,
    sitePath: string,
  ): Promise<string[]> {
    try {
      // Use WP-CLI to verify core checksums
      const command = `cd ${sitePath} && wp core verify-checksums --allow-root 2>&1 | grep "^Warning" | head -20`;

      const result = await this.sshExecutor.executeCommand(serverId, command, 60000);
      return result
        .split('\n')
        .filter((line) => line.trim() !== '')
        .map((line) => line.replace('Warning: ', '').trim());
    } catch (error) {
      // If command fails, core might be compromised
      return [];
    }
  }

  getCheckType(): DiagnosisCheckType {
    return DiagnosisCheckType.MALWARE_SCAN;
  }

  getPriority(): CheckPriority {
    return CheckPriority.CRITICAL;
  }

  getName(): string {
    return 'Malware Detection';
  }

  getDescription(): string {
    return 'Scans for malware, backdoors, suspicious files, and unauthorized access';
  }

  canHandle(checkType: DiagnosisCheckType): boolean {
    return checkType === DiagnosisCheckType.MALWARE_SCAN;
  }
}
